<!DOCTYPE html>
<!-- saved from url=(0088)https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html -->
<html lang="en" class=""><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>Reverse Engineering the Win32k Type Isolation Mitigation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Fred Raynal">


    <!-- Le styles -->
    <link rel="stylesheet" href="./Reverse Engineering the Win32k Type Isolation Mitigation_files/bootstrap.min.css" type="text/css">
    <style type="text/css">
      body {
        padding-top: 60px;
        padding-bottom: 40px;
      }
      .sidebar-nav {
        padding: 9px 0;
      }
      .tag-1 {
        font-size: 13pt;
      }
      .tag-2 {
        font-size: 10pt;
      }
      .tag-2 {
        font-size: 8pt;
      }
      .tag-4 {
        font-size: 6pt;
      }
    </style>
    <link href="./Reverse Engineering the Win32k Type Isolation Mitigation_files/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="./Reverse Engineering the Win32k Type Isolation Mitigation_files/font-awesome.css" rel="stylesheet">

    <link href="./Reverse Engineering the Win32k Type Isolation Mitigation_files/pygments.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
    <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="https://blog.quarkslab.com/theme/img/favicon.ico">
    <link rel="apple-touch-icon" href="https://blog.quarkslab.com/theme/img/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://blog.quarkslab.com/theme/img/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://blog.quarkslab.com/theme/img/apple-touch-icon-114x114.png">

    <link href="https://blog.quarkslab.com/" type="application/atom+xml" rel="alternate" title="Quarkslab&#39;s blog ATOM Feed">

  <style type="text/css" abt="234"></style><script type="text/javascript" async="" src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/embed.js.下载"></script><script async="" type="text/javascript" src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/count.js.下载"></script><script>//console.log('a')
</script><script>doAdblock();
function doAdblock(){
    (function() {
        function A() {}
        A.prototype = {
            rules: {
                'pps_pps': {
                    'find': /^http:\/\/www\.iqiyi\.com\/player\/cupid\/common\/pps_flvplay_s\.swf/,
                    'replace': 'http://swf.adtchrome.com/pps_20140420.swf'
                },
                '17173_in':{
                    'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/PreloaderFile(Customer)?\.swf/,
                    'replace':"http://swf.adtchrome.com/17173_in_20150522.swf"
                },
                '17173_out':{
                    'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/PreloaderFileFirstpage\.swf/,
                    'replace':"http://swf.adtchrome.com/17173_out_20150522.swf"
                },
                '17173_live':{
                    'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/Player_stream(_firstpage)?\.swf/,
                    'replace':"http://swf.adtchrome.com/17173_stream_20150522.swf"
                },
                '17173_live_out':{
                    'find':/http:\/\/f\.v\.17173cdn\.com\/(\d+\/)?flash\/Player_stream_(custom)?Out\.swf/,
                    'replace':"http://swf.adtchrome.com/17173.out.Live.swf"
                }
            },
            _done: null,
            get done() {
                if(!this._done) {
                    this._done = new Array();
                }
                return this._done;
            },
            addAnimations: function() {
                var style = document.createElement('style');
                style.type = 'text/css';
                style.innerHTML = 'object,embed{\
                -webkit-animation-duration:.001s;-webkit-animation-name:playerInserted;\
                -ms-animation-duration:.001s;-ms-animation-name:playerInserted;\
                -o-animation-duration:.001s;-o-animation-name:playerInserted;\
                animation-duration:.001s;animation-name:playerInserted;}\
                @-webkit-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}\
                @-ms-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}\
                @-o-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}\
                @keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}';
                document.getElementsByTagName('head')[0].appendChild(style);
            },
            animationsHandler: function(e) {
                if(e.animationName === 'playerInserted') {
                    this.replace(e.target);
                }
            },
            replace: function(elem) {
                if (/http:\/\/v.youku.com\/v_show\/.*/.test(window.location.href)){
                    var tag = document.getElementById("playerBox").getAttribute("player")
                    if (tag == "adt"){
                        console.log("adt adv")
                        return;
                    }
                }
                if(this.done.indexOf(elem) != -1) return;
                this.done.push(elem);
                var player = elem.data || elem.src;
                if(!player) return;
                var i, find, replace = false;
                for(i in this.rules) {
                    find = this.rules[i]['find'];
                    if(find.test(player)) {
                        replace = this.rules[i]['replace'];
                        if('function' === typeof this.rules[i]['preHandle']) {
                            this.rules[i]['preHandle'].bind(this, elem, find, replace, player)();
                        }else{
                            this.reallyReplace.bind(this, elem, find, replace)();
                        }
                        break;
                    }
                }
            },
            reallyReplace: function(elem, find, replace) {
                elem.data && (elem.data = elem.data.replace(find, replace)) || elem.src && ((elem.src = elem.src.replace(find, replace)) && (elem.style.display = 'block'));
                var b = elem.querySelector("param[name='movie']");
                this.reloadPlugin(elem);
            },
            reloadPlugin: function(elem) {
                var nextSibling = elem.nextSibling;
                var parentNode = elem.parentNode;
                parentNode.removeChild(elem);
                var newElem = elem.cloneNode(true);
                this.done.push(newElem);
                if(nextSibling) {
                    parentNode.insertBefore(newElem, nextSibling);
                } else {
                    parentNode.appendChild(newElem);
                }
            },
            init: function() {
                var handler = this.animationsHandler.bind(this);
                document.body.addEventListener('webkitAnimationStart', handler, false);
                document.body.addEventListener('msAnimationStart', handler, false);
                document.body.addEventListener('oAnimationStart', handler, false);
                document.body.addEventListener('animationstart', handler, false);
                this.addAnimations();
            }
        };
        new A().init();
    })();
}
// 20140730
(function cnbeta() {
    if (document.URL.indexOf('cnbeta.com') >= 0) {
        var elms = document.body.querySelectorAll("p>embed");
        Array.prototype.forEach.call(elms, function(elm) {
            elm.style.marginLeft = "0px";
        });
    }
})();
//baidu
if(document.URL.indexOf('www.baidu.com') >= 0){
    if(document && document.getElementsByTagName && document.getElementById && document.body){
        var aa = function(){
            var all = document.body.querySelectorAll("#content_left div,#content_left table");
            for(var i = 0; i < all.length; i++){
                if(/display:\s?(table|block)\s!important/.test(all[i].getAttribute("style"))){all[i].style.display= "none";all[i].style.visibility='hidden';}
            }
            all = document.body.querySelectorAll('.result.c-container[id="1"]');
            //if(all.length == 1) return;
            for(var i = 0; i < all.length; i++){
                if(all[i].innerHTML && all[i].innerHTML.indexOf('广告')>-1){
                    all[i].style.display= "none";all[i].style.visibility='hidden';
                }
            }
        }
        aa();
        document.getElementById('wrapper_wrapper').addEventListener('DOMSubtreeModified',aa)
    };
}
// 20140922
(function kill_360() {
    if (document.URL.indexOf('so.com') >= 0) {
        document.getElementById("e_idea_pp").style.display = none;
    }
})();
if (document.URL.indexOf("tv.sohu.com") >= 0){
    if (document.cookie.indexOf("fee_status=true")==-1){document.cookie='fee_status=true'};
}
if (document.URL.indexOf("56.com") >= 0){
    if (document.cookie.indexOf("fee_status=true")==-1){document.cookie='fee_status=true'};
}
if (document.URL.indexOf("iqiyi.com") >= 0){
    if (document.cookie.indexOf("player_forcedType=h5_VOD")==-1){
        document.cookie='player_forcedType=h5_VOD'
        if(localStorage.reloadTime && Date.now() - parseInt(localStorage.reloadTime)<60000){
            console.log('no reload')
        }else{
            location.reload()
            localStorage.reloadTime = Date.now();
        }
    }
}
</script><style type="text/css">object,embed{                -webkit-animation-duration:.001s;-webkit-animation-name:playerInserted;                -ms-animation-duration:.001s;-ms-animation-name:playerInserted;                -o-animation-duration:.001s;-o-animation-name:playerInserted;                animation-duration:.001s;animation-name:playerInserted;}                @-webkit-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-ms-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-o-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}</style><link rel="preload" as="style" href="https://c.disquscdn.com/next/embed/styles/lounge.2d848eddee1b8c12749b72a04b2b33dc.css"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/common.bundle.845ead53749f15d0bd8a5ee344c8f06e.js"><link rel="preload" as="script" href="https://c.disquscdn.com/next/embed/lounge.bundle.7b984c87b2825d6651408c24c7a8a583.js"><link rel="preload" as="script" href="https://disqus.com/next/config.js"><link type="text/css" rel="stylesheet" charset="UTF-8" href="./Reverse Engineering the Win32k Type Isolation Mitigation_files/translateelement.css"></head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container-fluid">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="https://blog.quarkslab.com/index.html">Quarkslab's blog </a>
          <div class="nav-collapse">
            <ul class="nav">
              <li class="divider-vertical"></li>
                  <li>
                    <a href="https://blog.quarkslab.com/category/android.html">
                      <i class="icon-folder-open icon-large"></i>Android
                    </a>
                  </li>
                  <li>
                    <a href="https://blog.quarkslab.com/category/challenge.html">
                      <i class="icon-folder-open icon-large"></i>Challenge
                    </a>
                  </li>
                  <li>
                    <a href="https://blog.quarkslab.com/category/cryptography.html">
                      <i class="icon-folder-open icon-large"></i>Cryptography
                    </a>
                  </li>
                  <li>
                    <a href="https://blog.quarkslab.com/category/development.html">
                      <i class="icon-folder-open icon-large"></i>Development
                    </a>
                  </li>
                  <li>
                    <a href="https://blog.quarkslab.com/category/exploitation.html">
                      <i class="icon-folder-open icon-large"></i>Exploitation
                    </a>
                  </li>
                  <li>
                    <a href="https://blog.quarkslab.com/category/fuzzing.html">
                      <i class="icon-folder-open icon-large"></i>Fuzzing
                    </a>
                  </li>
                  <li>
                    <a href="https://blog.quarkslab.com/category/hardware.html">
                      <i class="icon-folder-open icon-large"></i>Hardware
                    </a>
                  </li>

              <ul class="nav pull-right">
                <li><a href="https://blog.quarkslab.com/archives.html"><i class="icon-th-list"></i>Archives</a></li>
              </ul>

            </ul>
            <!--<p class="navbar-text pull-right">Logged in as <a href="#">username</a></p>-->
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container-fluid">
      <div class="row">

        <div class="span3 well sidebar-nav" id="sidebar">
<ul class="nav nav-list">
<li class="nav-header"><h4><i class="icon-home icon-large"></i> social</h4></li>
<li><a href="https://blog.quarkslab.com/feeds/all.rss.xml" rel="alternate"><i class="icon-bookmark icon-large"></i>atom feed</a></li>
    <li><a href="https://twitter.com/quarkslab"><i class="icon-twitter-sign icon-large"></i>twitter</a></li>
    <li><a href="https://github.com/quarkslab"><i class="icon-github-sign icon-large"></i>github</a></li>

<li class="nav-header"><h4><i class="icon-folder-close icon-large"></i>Categories</h4></li>
<li>
<a href="https://blog.quarkslab.com/category/android.html">
    <i class="icon-folder-open icon-large"></i>Android
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/challenge.html">
    <i class="icon-folder-open icon-large"></i>Challenge
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/cryptography.html">
    <i class="icon-folder-open icon-large"></i>Cryptography
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/development.html">
    <i class="icon-folder-open icon-large"></i>Development
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/exploitation.html">
    <i class="icon-folder-open icon-large"></i>Exploitation
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/fuzzing.html">
    <i class="icon-folder-open icon-large"></i>Fuzzing
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/hardware.html">
    <i class="icon-folder-open icon-large"></i>Hardware
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/life-at-quarkslab.html">
    <i class="icon-folder-open icon-large"></i>Life at Quarkslab
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/maths.html">
    <i class="icon-folder-open icon-large"></i>Maths
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/pentest.html">
    <i class="icon-folder-open icon-large"></i>PenTest
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/program-analysis.html">
    <i class="icon-folder-open icon-large"></i>Program Analysis
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/programming.html">
    <i class="icon-folder-open icon-large"></i>Programming
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/reverseengineering.html">
    <i class="icon-folder-open icon-large"></i>ReverseEngineering
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/software.html">
    <i class="icon-folder-open icon-large"></i>Software
</a>
</li>
<li>
<a href="https://blog.quarkslab.com/category/vulnerability.html">
    <i class="icon-folder-open icon-large"></i>Vulnerability
</a>
</li>

<li class="nav-header"><h4><i class="icon-tags icon-large"></i>Tags</h4></li>


</ul>        </div><!--/.well -->

        <div class="span9">
<section id="content">
<article>
<header>
<h1>
  <a href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html" rel="bookmark" title="Permalink to Reverse Engineering the Win32k Type Isolation Mitigation">
    Reverse Engineering the Win32k Type Isolation Mitigation
  </a>
</h1>
</header>
<div class="entry-content">
  <div class="well">
<footer class="post-info">
<span class="label">Date</span>
<abbr class="published" title="2018-02-02T00:00:00+01:00">
        <i class="icon-calendar"></i>Fri 02 February 2018
</abbr>
<span class="label">By</span>
<a href="https://blog.quarkslab.com/author/francisco-falcon.html"><i class="icon-user"></i>Francisco Falcon</a>
<span class="label">Category</span>
<a href="https://blog.quarkslab.com/category/reverseengineering.html"><i class="icon-folder-open"></i>ReverseEngineering</a>.


<span class="label">Tags</span>
	<a href="https://blog.quarkslab.com/tag/windows.html"><i class="icon-tag"></i>Windows</a>
	<a href="https://blog.quarkslab.com/tag/exploitation.html"><i class="icon-tag"></i>Exploitation</a>
</footer><!-- /.post-info -->  </div>

  <div class="summary"><p class="first last">Given the popularity of GDI Bitmap objects for exploitation of kernel vulnerabilities -due to the fact that almost any kind of memory corruption vulnerability (except for NULL-writes) could be used to reliably gain arbitrary R/W primitives over the kernel memory by abusing Bitmaps- Microsoft decided to kill exploitation techniques based on Bitmaps. In order to do this, Windows 10 <em>Fall Creators Update</em> (also known as Windows 10 1709) introduced the <strong>Type Isolation</strong> feature, an exploitation mitigation in the Win32k subsystem, which splits the memory layout of <tt class="docutils literal">SURFACE</tt> objects, the internal representation of Bitmaps on the kernel side. This blogpost takes a deep dive into the details of how Type Isolation is implemented.</p>
</div>

  <div class="section" id="analysis-notes">
<h2>Analysis Notes</h2>
<p>This analysis was initially performed using <tt class="docutils literal">win32kbase.sys</tt> version 10.0.16288.1 on Windows 10 Fall Creators Update x64, which was one of the last Insider Preview builds before the general availability of Windows 10 1709 in October 2017. Doing a binary diff between said version and the latest <tt class="docutils literal">win32kbase.sys</tt> version 10.0.16299.125 available as of this writing (end of January 2018), shows that the functions relevant to Type Isolation remain unchanged.</p>
</div>
<div class="section" id="context">
<h2>Context</h2>
<p>Since mid-2015, Bitmaps <a class="footnote-reference" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id8" id="id1">[1]</a>, a type of GDI objects, have been the preferred choice of exploit developers when exploiting kernel vulnerabilities on Windows.
The data structure representing this type of object on the Windows kernel turned out to have some very handy members, which when corrupted via a memory safety vulnerability, could provide an attacker with full-blown R/W access to the kernel address space.</p>
<p>On the kernel side, a Bitmap is represented by a <tt class="docutils literal">SURFACE</tt> object using the following structure:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SURFACE</span> <span class="p">{</span>
    <span class="n">BASEOBJECT</span> <span class="n">BaseObject</span><span class="p">;</span>
    <span class="n">SURFOBJ</span> <span class="n">surfobj</span><span class="p">;</span>
    <span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
<p><tt class="docutils literal">BASEOBJECT</tt> is common to several types of objects, and it's defined this way:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_BASEOBJECT</span> <span class="p">{</span>
    <span class="n">HANDLE</span> <span class="n">hHmgr</span><span class="p">;</span>
    <span class="n">ULONG</span>  <span class="n">ulShareCount</span><span class="p">;</span>
    <span class="n">USHORT</span> <span class="n">cExclusiveLock</span><span class="p">;</span>
    <span class="n">USHORT</span> <span class="n">BaseFlags</span><span class="p">;</span>
    <span class="n">PVOID</span>  <span class="n">Tid</span><span class="p">;</span>
<span class="p">}</span> <span class="n">BASEOBJECT</span><span class="p">,</span> <span class="o">*</span><span class="n">PBASEOBJECT</span><span class="p">;</span>
</pre></div>
<p>But we are interested in the SURFACE-specific structure, which is called <tt class="docutils literal">SURFOBJ</tt>, and it's defined like this:</p>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_SURFOBJ</span> <span class="p">{</span>
    <span class="n">DHSURF</span> <span class="n">dhsurf</span><span class="p">;</span>
    <span class="n">HSURF</span>  <span class="n">hsurf</span><span class="p">;</span>
    <span class="n">DHPDEV</span> <span class="n">dhpdev</span><span class="p">;</span>
    <span class="n">HDEV</span>   <span class="n">hdev</span><span class="p">;</span>
    <span class="n">SIZEL</span>  <span class="n">sizlBitmap</span><span class="p">;</span>
    <span class="n">ULONG</span>  <span class="n">cjBits</span><span class="p">;</span>
    <span class="n">PVOID</span>  <span class="n">pvBits</span><span class="p">;</span>
    <span class="n">PVOID</span>  <span class="n">pvScan0</span><span class="p">;</span>
    <span class="n">LONG</span>   <span class="n">lDelta</span><span class="p">;</span>
    <span class="n">ULONG</span>  <span class="n">iUniq</span><span class="p">;</span>
    <span class="n">ULONG</span>  <span class="n">iBitmapFormat</span><span class="p">;</span>
    <span class="n">USHORT</span> <span class="n">iType</span><span class="p">;</span>
    <span class="n">USHORT</span> <span class="n">fjBitmap</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SURFOBJ</span><span class="p">,</span> <span class="o">*</span><span class="n">PSURFOBJ</span><span class="p">;</span>
</pre></div>
<p>The two most interesting members of this structure are <tt class="docutils literal">pvScan0</tt>, which points to the buffer holding the pixel data of the Bitmap, and <tt class="docutils literal">sizlBitmap</tt>, which holds the dimensions (width and height) of the Bitmap.</p>
<p>There are two main ways to take advantage of <tt class="docutils literal">SURFACE</tt> objects for exploitation purposes, by corrupting the members mentioned before:</p>
<blockquote>
<ol class="arabic simple">
<li>Both the <tt class="docutils literal">GetBitmapBits</tt> and <tt class="docutils literal">SetBitmapBits</tt> GDI APIs operate on the pixel data buffer pointed by the <tt class="docutils literal">pvScan0</tt> member of the <tt class="docutils literal">SURFOBJ</tt> structure. Overwriting this pointer provides arbitrary R/W of kernel memory from user mode.</li>
<li>The <tt class="docutils literal">sizlBitmap</tt> member of the <tt class="docutils literal">SURFOBJ</tt> structure holds the <strong>width</strong> and <strong>height</strong> properties of the Bitmap. By overwriting <tt class="docutils literal">sizlBitmap.cx</tt> or <tt class="docutils literal">sizlBitmap.cy</tt> it's possible to "enlarge" the pixel data buffer. This provides R/W access to kernel memory beyond the end of the pixel data buffer.</li>
</ol>
</blockquote>
<p>Both ways end up setting up a Manager/Worker scheme where 2 Bitmap objects are involved; if you want to study this topic in depth, I recommend reading the slides from the 2016 Ekoparty conference presentation titled "Abusing GDI for ring0 exploit primitives: Reloaded" <a class="footnote-reference" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id9" id="id2">[2]</a>, by Diego Juárez and Nicolás Economou.</p>
<p>The first technique provides full R/W capabilities. Its disadvantage is that it requires a "good" vulnerability (such as a write-what-where), which should allow to overwrite the <tt class="docutils literal">pvScan0</tt> pointer with an arbitrary value.</p>
<p>The second technique, although less powerful at first, since it initially provides R/W access to the memory located right after the end of the pixel data buffer, has the advantage of being usable even with limited vulnerabilities; simple arbitrary decrements/increments, or writing non-arbitrary values will do the trick.
The exploitation strategy when overwriting the <tt class="docutils literal">sizlBitmap</tt> member of the <tt class="docutils literal">SURFOBJ</tt> structure is to make two <tt class="docutils literal">SURFACE</tt> objects (let's call them <em>SURFACE1</em> and <em>SURFACE2</em>) adjacent in memory; by corrupting the <tt class="docutils literal">sizlBitmap</tt> of <em>SURFACE1</em>, its pixel data buffer is "enlarged", thus overlapping with the adjacent <em>SURFACE2</em> object. From that point, further operations on the (now enlarged) <em>SURFACE1</em> can arbitrarily overwrite members of the <em>SURFACE2</em> header, effectively transforming the limited R/W beyond the bounds of the <em>SURFACE1</em> pixel buffer into fully arbitrary R/W capabilities.</p>
<p>As you may have noticed, this <strong>second exploitation approach has been possible because, until now, the pixel data buffer of a Bitmap was typically contiguous to the SURFACE header; the whole SURFACE object was created through a single memory allocation, with size big enough to hold both the SURFACE header plus the pixel data buffer. It didn't have to be necessarily like that, but it was implemented that way</strong>. This made possible for exploit developers to obtain advantageous memory layouts, where the pixel data buffer of one <tt class="docutils literal">SURFACE</tt> object can be followed by the header of another one.</p>
<p>Given this second exploitation approach, which allows to turn almost any kind of memory corruption vulnerability (except for NULL-writes) into arbitrary R/W over the kernel memory by abusing GDI Bitmap objects, Microsoft decided to kill it. In order to do this, Windows 10 <em>Fall Creators Update</em> introduced the <strong>Type Isolation</strong> feature, an exploitation mitigation in the Win32k subsystem, which splits the memory layout of <tt class="docutils literal">SURFACE</tt> objects.</p>
</div>
<div class="section" id="type-isolation">
<h2>Type Isolation</h2>
<div class="section" id="data-structures">
<h3>Data Structures</h3>
<p><tt class="docutils literal">Type Isolation</tt> is implemented through a number of linked structures. There are 4 main data structures involved in this mitigation (you can find below a cute lil' diagram that explains everything in a graphical way):</p>
<ul class="simple">
<li><tt class="docutils literal">CTypeIsolation</tt></li>
<li><tt class="docutils literal">CSectionEntry</tt></li>
<li><tt class="docutils literal">CSectionBitmapAllocator</tt></li>
<li><tt class="docutils literal">RTL_BITMAP</tt> (although not unique to Type Isolation, this well-known Windows kernel opaque structure plays an important role here)</li>
</ul>
<p>All of them are allocated from the <tt class="docutils literal">PagedPoolSession</tt> pool using <tt class="docutils literal">ExAllocatePoolWithTag</tt>. They all share a new 4-byte pool tag, which is '<em>Uiso</em>'.
Also, the pool tag used for the pixel data buffer of <tt class="docutils literal">SURFACE</tt> objects has changed, from '<em>Gh?5</em>' to '<em>Gpbm</em>'.</p>
<p>The <tt class="docutils literal">win32kbase!gpTypeIsolation</tt> static variable is a pointer to another pointer, which in turn points to a global <tt class="docutils literal">CTypeIsolation</tt> structure. This <tt class="docutils literal">CTypeIsolation</tt> is the head of a circular doubly-linked list of <tt class="docutils literal">CSectionEntry</tt> objects.
Each <tt class="docutils literal">CSectionEntry</tt> manages 0xF0 <tt class="docutils literal">SURFACE</tt> headers. Each <tt class="docutils literal">CSectionEntry</tt> owns a <tt class="docutils literal">CSectionBitmapAllocator</tt> object, which maintains two main objects in sync: an array of 0x28 <tt class="docutils literal">Views</tt> over a <tt class="docutils literal">Section</tt> <a class="footnote-reference" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id10" id="id3">[3]</a>, with each <tt class="docutils literal">View</tt> being able to hold 6 <tt class="docutils literal">SURFACE</tt> headers, and a map of bits (<tt class="docutils literal">RTL_BITMAP</tt>) that keeps track of the busy or free state of each one of the <tt class="docutils literal">0x28 * 6 == 0xF0</tt> available slots in the <tt class="docutils literal">Views</tt>.
The doubly-linked list of <tt class="docutils literal">CSectionEntry</tt> objects can grow as needed.</p>
<p>The reverse-engineered definitions of the 4 mentioned data structures follow, along with their sizes and the offsets of their members:</p>
<ul class="simple">
<li><strong>CTypeIsolation</strong> (size = 0x20 bytes)</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_CTYPEISOLATION</span> <span class="p">{</span>
    <span class="n">PCSECTIONENTRY</span>  <span class="n">next</span><span class="p">;</span>           <span class="c1">// + 0x00</span>
    <span class="n">PCSECTIONENTRY</span>  <span class="n">previous</span><span class="p">;</span>       <span class="c1">// + 0x08</span>
    <span class="n">PVOID</span>           <span class="n">pushlock</span><span class="p">;</span>       <span class="c1">// + 0x10</span>
    <span class="n">ULONG64</span>         <span class="n">size</span><span class="p">;</span>           <span class="c1">// + 0x18</span>
<span class="p">}</span> <span class="n">CTYPEISOLATION</span><span class="p">,</span> <span class="o">*</span><span class="n">PCTYPEISOLATION</span><span class="p">;</span>
</pre></div>
<ul class="simple">
<li><strong>CSectionEntry</strong> (size = 0x28 bytes)</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_CSECTIONENTRY</span> <span class="n">CSECTIONENTRY</span><span class="p">,</span> <span class="o">*</span><span class="n">PCSECTIONENTRY</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">_CSECTIONENTRY</span> <span class="p">{</span>
    <span class="n">CSECTIONENTRY</span>   <span class="o">*</span><span class="n">next</span><span class="p">;</span>          <span class="c1">// + 0x00</span>
    <span class="n">CSECTIONENTRY</span>   <span class="o">*</span><span class="n">previous</span><span class="p">;</span>      <span class="c1">// + 0x08</span>
    <span class="n">PVOID</span>           <span class="n">section</span><span class="p">;</span>        <span class="c1">// + 0x10</span>
    <span class="n">PVOID</span>           <span class="n">view</span><span class="p">;</span>           <span class="c1">// + 0x18</span>
    <span class="n">PCSECTIONBITMAPALLOCATOR</span> <span class="n">bitmap_allocator</span><span class="p">;</span>  <span class="c1">// + 0x20</span>
<span class="p">};</span>
</pre></div>
<ul class="simple">
<li><strong>CSectionBitmapAllocator</strong> (size = 0x28 bytes)</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_CSECTIONBITMAPALLOCATOR</span> <span class="p">{</span>
    <span class="n">PVOID</span>           <span class="n">pushlock</span><span class="p">;</span>           <span class="c1">// + 0x00</span>
    <span class="n">ULONG64</span>         <span class="n">xored_view</span><span class="p">;</span>         <span class="c1">// + 0x08</span>
    <span class="n">ULONG64</span>         <span class="n">xor_key</span><span class="p">;</span>            <span class="c1">// + 0x10</span>
    <span class="n">ULONG64</span>         <span class="n">xored_rtl_bitmap</span><span class="p">;</span>   <span class="c1">// + 0x18</span>
    <span class="n">ULONG</span>           <span class="n">bitmap_hint_index</span><span class="p">;</span>  <span class="c1">// + 0x20</span>
    <span class="n">ULONG</span>           <span class="n">num_commited_views</span><span class="p">;</span> <span class="c1">// + 0x24</span>
<span class="p">}</span> <span class="n">CSECTIONBITMAPALLOCATOR</span><span class="p">,</span> <span class="o">*</span><span class="n">PCSECTIONBITMAPALLOCATOR</span><span class="p">;</span>
</pre></div>
<ul class="simple">
<li><strong>RTL_BITMAP</strong> (size = 0x10 bytes)</li>
</ul>
<div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_RTL_BITMAP</span> <span class="p">{</span>
    <span class="n">ULONG64</span>         <span class="n">size</span><span class="p">;</span>               <span class="c1">// + 0x00</span>
    <span class="n">PVOID</span>           <span class="n">bitmap_buffer</span><span class="p">;</span>      <span class="c1">// + 0x08</span>
<span class="p">}</span> <span class="n">RTL_BITMAP</span><span class="p">,</span> <span class="o">*</span><span class="n">PRTL_BITMAP</span><span class="p">;</span>
</pre></div>
<p>The following diagram tries to clarify the relationship between all the involved data structures.</p>
<img alt="" class="align-center" src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/data-structures.png" style="width: 600px;">
<p>This figure represents an hypothetical state of the Type Isolation structures with 3 <tt class="docutils literal">CSectionEntry</tt> instances, each one with their associated <tt class="docutils literal">CSectionBitmapAllocator</tt> and <tt class="docutils literal">RTL_BITMAP</tt> instances. Since each instance of <tt class="docutils literal">CSectionEntry</tt> manages 0xF0 <tt class="docutils literal">SURFACE</tt> headers, the <tt class="docutils literal">size</tt> member of the <tt class="docutils literal">CTypeIsolation</tt> object is set to <tt class="docutils literal">0xF0 * 3 == 0x2D0</tt>.</p>
<p>The 0x28 <tt class="docutils literal">Views</tt> of size 0x1000 backing the first <tt class="docutils literal">CSectionEntry</tt> are also represented. In this case, only 2 out of 0x28 <tt class="docutils literal">Views</tt> are committed; the rest of them remain unmapped until needed.
The first <tt class="docutils literal">View</tt> is <em>full</em>: all the 6 slots of size 0x280 are in use by <tt class="docutils literal">SURFACE</tt> headers (the 0x100 spare bytes at the end of the page are not pictured here). The second <tt class="docutils literal">View</tt> is only half full: 3 0x280-byte slots are in use, while the last 3 slots remain unused. At the same time, the free/busy status of each slot is kept in sync with the map of bits in the <tt class="docutils literal">RTL_BITMAP</tt> belonging to the same <tt class="docutils literal">CSectionEntry</tt>. In this hypothetical situation where the first 9 slots are in use and the rest are free, the map of bits would look like this: <tt class="docutils literal">11111111 00000001 00000000 00000000 ...</tt>.</p>
<p>Also, notice that this figure doesn't picture the <tt class="docutils literal">Section</tt> object backing the <tt class="docutils literal">Views</tt> objects for the sake of simplicity, since no direct access is done to the <tt class="docutils literal">Section</tt> (all the accesses are done through the <tt class="docutils literal">Views</tt>).</p>
<p>As a separate remark, the <tt class="docutils literal"><span class="pre">win32kbase!SURFACE::tSize</span></tt> static variable, which holds the size in bytes of a <tt class="docutils literal">SURFACE</tt> header, has value 0x278. However, through all the code analyzed here, calculations are done for a size of 0x280 bytes per <tt class="docutils literal">SURFACE</tt> header, probably just for alignment purposes.</p>
<div class="highlight"><pre><span></span>.data:00000001C0196110 ; Exported entry 387. ?tSize@SURFACE@@0_KA
.data:00000001C0196110                 public private: static unsigned __int64 SURFACE::tSize
.data:00000001C0196110 private: static unsigned __int64 SURFACE::tSize dq 278h
</pre></div>
</div>
<div class="section" id="initialization">
<h3>Initialization</h3>
<p>Initialization of the Type Isolation structures happens inside <tt class="docutils literal">win32kbase!HmgCreate()</tt>, which gets called during the initialization of the <tt class="docutils literal">win32kbase.sys</tt> driver.
It starts by allocating a pointer to the future head <tt class="docutils literal"><span class="pre">NSInstrumentation::CTypeIsolation</span></tt> structure, and saving it to the <tt class="docutils literal">win32kbase!gpTypeIsolation</tt> global variable.
Then it calls the <tt class="docutils literal"><span class="pre">CTypeIsolation::Create()</span></tt> method, which allocates the head <tt class="docutils literal">CTypeIsolation</tt> structure.</p>
<div class="highlight"><pre><span></span>HmgCreate+397                  mov     edx, 'osiU'
HmgCreate+39C                  mov     rcx, r14        ; size = 8 (ptr to CTypeIsolation)
HmgCreate+39F                  call    Win32AllocPool
HmgCreate+3A4                  mov     cs:uchar * * gpTypeIsolation, rax
HmgCreate+3AB                  test    rax, rax
HmgCreate+3AE                  jz      short loc_1C0012561
HmgCreate+3B0                  xor     ecx, ecx
HmgCreate+3B2                  mov     [rax], rcx
HmgCreate+3B5                  call    TypeIsolationFactory&lt;NSInstrumentation::CTypeIsolation&lt;163840,640&gt;&gt;::Create(uchar * *)
</pre></div>
<p><tt class="docutils literal"><span class="pre">CTypeIsolation::Create()</span></tt> allocates 0x20 bytes for the <tt class="docutils literal">CTypeIsolation</tt> object, and then calls <tt class="docutils literal"><span class="pre">CTypeIsolation::Initialize()</span></tt> to initialize it. If everything went fine, the address of the <tt class="docutils literal">CTypeIsolation</tt> object is saved to the pointer referenced by <tt class="docutils literal">win32kbase!gpTypeIsolation</tt>.</p>
<div class="highlight"><pre><span></span>.text:00000001C001263C public: static bool TypeIsolationFactory&lt;class NSInstrumentation::CTypeIsolation&lt;163840, 640&gt;&gt;::Create(unsigned char * *) proc near
[...]
.text:00000001C001264D                 mov     edx, 20h        ; NumberOfBytes
.text:00000001C0012652                 mov     r8d, 'osiU'     ; Tag
.text:00000001C0012658                 lea     ecx, [rdx+1]    ; PoolType
.text:00000001C001265B                 call    cs:__imp_ExAllocatePoolWithTag ; allocates a NSInstrumentation::CTypeIsolation object
.text:00000001C0012661                 mov     rbx, rax        ; rbx = CTypeIsolation object
.text:00000001C0012664                 test    rax, rax
.text:00000001C0012667                 jz      short loc_1C0012699
.text:00000001C0012669                 and     qword ptr [rax+10h], 0 ; CTypeIsolation-&gt;pushlock = NULL
.text:00000001C001266E                 mov     rcx, rax
.text:00000001C0012671                 and     dword ptr [rax+18h], 0 ; CTypeIsolation-&gt;size = 0
.text:00000001C0012675                 mov     [rax+8], rax    ; CTypeIsolation-&gt;previous = this
.text:00000001C0012679                 mov     [rax], rax      ; CTypeIsolation-&gt;next = this
.text:00000001C001267C                 call    NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::Initialize(void)
.text:00000001C0012681                 test    al, al
.text:00000001C0012683                 jz      loc_1C00BA344
.text:00000001C0012689                 mov     [rdi], rbx      ; *win32kbase!gpTypeIsolation = CTypeIsolation
</pre></div>
<p>Most notably, <tt class="docutils literal"><span class="pre">CTypeIsolation::Initialize()</span></tt> creates a <tt class="docutils literal">CSectionEntry</tt> structure by calling <tt class="docutils literal"><span class="pre">CSectionEntry::Create()</span></tt>, and assigns it to both the <tt class="docutils literal">next</tt> and <tt class="docutils literal">previous</tt> members of the <tt class="docutils literal">CTypeIsolation</tt> object:</p>
<div class="highlight"><pre><span></span>.text:00000001C0039A34 private: bool NSInstrumentation::CTypeIsolation&lt;163840, 640&gt;::Initialize(void) proc near
[...]
.text:00000001C0039A5E                 call    NSInstrumentation::CSectionEntry&lt;163840,640&gt;::Create(void)
.text:00000001C0039A63                 test    rax, rax        ; rax == CSectionEntry object
.text:00000001C0039A66                 jz      short loc_1C0039A92
.text:00000001C0039A68                 mov     rcx, [rbx+8]    ; rcx = CTypeIsolation-&gt;previous
.text:00000001C0039A6C                 mov     dword ptr [rbx+18h], 0F0h ; CTypeIsolation-&gt;size = 0xF0
.text:00000001C0039A73                 cmp     [rcx], rbx      ; CTypeIsolation-&gt;previous-&gt;next == CTypeIsolation?
.text:00000001C0039A76                 jnz     FatalListEntryError_10
.text:00000001C0039A7C                 mov     [rax], rbx      ; CSectionEntry-&gt;next= CTypeIsolation
.text:00000001C0039A7F                 mov     [rax+8], rcx    ; CSectionEntry-&gt;previous = CTypeIsolation-&gt;previous
.text:00000001C0039A83                 mov     [rcx], rax      ; *CTypeIsolation-&gt;previous-&gt;next = CSectionEntry
.text:00000001C0039A86                 mov     [rbx+8], rax    ; CTypeIsolation-&gt;previous = CSectionEntry
</pre></div>
<p>In turn, <tt class="docutils literal"><span class="pre">CSectionEntry::Create()</span></tt> calls <tt class="docutils literal"><span class="pre">CSectionEntry::Initialize()</span></tt>, which creates a <tt class="docutils literal">Section</tt> object by calling <tt class="docutils literal">nt!MmCreateSection()</tt>.
The size of this <tt class="docutils literal">Section</tt> is 0x28000 bytes; this <tt class="docutils literal">Section</tt> will be accessed through 0x28 <tt class="docutils literal">Views</tt>, each one 0x1000 bytes in size.
A pointer to this <tt class="docutils literal">Section</tt> object is stored in the <tt class="docutils literal">CSectionEntry</tt> structure.</p>
<div class="highlight"><pre><span></span>.text:00000001C0099E5C                 lea     r9, [rbp+arg_0] ; MaximumSize
.text:00000001C0099E60                 xor     eax, eax
.text:00000001C0099E62                 mov     rdi, rcx        ; rdi = CSectionEntry object
.text:00000001C0099E65                 and     [r11-10h], rax
.text:00000001C0099E69                 lea     rcx, [rbp+SectionHandle] ; SectionHandle
.text:00000001C0099E6D                 and     [r11-18h], rax
.text:00000001C0099E71                 xor     r8d, r8d        ; ObjectAttributes
.text:00000001C0099E74                 mov     [rbp+arg_0], rax
.text:00000001C0099E78                 mov     edx, 0F001Fh    ; DesiredAccess = SECTION_ALL_ACCESS
.text:00000001C0099E7D                 mov     [rsp+40h+var_18], SEC_RESERVE ; AllocationAttributes
.text:00000001C0099E85                 mov     [rsp+40h+var_20], PAGE_READWRITE ; SectionPageProtection
.text:00000001C0099E8D                 mov     dword ptr [rbp+arg_0], 28000h ; size for the Section
.text:00000001C0099E94                 call    cs:__imp_MmCreateSection
</pre></div>
<p>Then it maps a <tt class="docutils literal">View</tt> of this <tt class="docutils literal">Section</tt>. A pointer to the view is also saved in the <tt class="docutils literal">CSectionEntry</tt> structure.</p>
<div class="highlight"><pre><span></span>.text:00000001C0099EB8                 mov     [rdi+10h], rcx  ; CSectionEntry-&gt;section = section
.text:00000001C0099EBC                 test    rcx, rcx
.text:00000001C0099EBF                 jz      short loc_1C0099F0F
.text:00000001C0099EC1                 and     [rbp+arg_0], 0
.text:00000001C0099EC6                 lea     rbx, [rdi+18h]  ; rbx = ptr to output view
.text:00000001C0099ECA                 mov     rdx, rbx
.text:00000001C0099ECD                 lea     r8, [rbp+arg_0]
.text:00000001C0099ED1                 call    cs:__imp_MmMapViewInSessionSpace ; populates CSectionEntry-&gt;view
</pre></div>
<p>Finally, <tt class="docutils literal"><span class="pre">CSectionEntry::Initialize()</span></tt> creates a <tt class="docutils literal">CSectionBitmapAllocator</tt> object by calling <tt class="docutils literal"><span class="pre">CSectionBitmapAllocator::Create()</span></tt>. A pointer to this object is stored in the <tt class="docutils literal">CSectionEntry</tt> structure.</p>
<div class="highlight"><pre><span></span>.text:00000001C0099EED                 mov     rcx, [rbx]      ; rcx = CSectionEntry-&gt;view
.text:00000001C0099EF0                 call    NSInstrumentation::CSectionBitmapAllocator&lt;163840,640&gt;::Create(uchar * const)
.text:00000001C0099EF5                 test    rax, rax        ; rax = CSectionBitmapAllocator
.text:00000001C0099EF8                 mov     [rdi+20h], rax  ; CSectionEntry-&gt;bitmap_allocator = CSectionBitmapAllocator
</pre></div>
<p>As expected, <tt class="docutils literal"><span class="pre">CSectionBitmapAllocator::Create()</span></tt> calls <tt class="docutils literal"><span class="pre">CSectionBitmapAllocator::Initialize()</span></tt>. This method allocates a pool buffer of size 0x30, which is used to hold a <tt class="docutils literal">RTL_BITMAP</tt> structure. Note that in this context, we are not talking about the GDI Bitmap objects, but about a general-purpose map of bits, which is typically used to keep track of a set of reusable items.
The first 0x10 bytes of that pool buffer are used to hold the header of the bitmap, while the remaining 0x20 bytes are used to store the map of bits itself. A buffer of 0x20 bytes can hold 0x100 bits, however only 0xF0 is specified as the number of bits when calling <tt class="docutils literal">nt!RtlInitializeBitMap</tt>, to match the number of <tt class="docutils literal">SURFACE</tt> slots that are handled by a <tt class="docutils literal">CSectionEntry</tt>. Then, all the bits in the bitmap are initialized to 0 by calling <tt class="docutils literal">nt!RtlClearAllBits</tt>.</p>
<div class="highlight"><pre><span></span>.text:00000001C009E324 allocate_rtl_bitmap proc near
[...]
.text:00000001C009E333                 mov     ecx, 21h        ; PoolType = PagedPoolSession
.text:00000001C009E338                 cmp     edx, edi
.text:00000001C009E33A                 mov     r8d, 'osiU'     ; Tag = 'Uiso'
.text:00000001C009E340                 cmovnb  edi, edx        ; edi = 0xF0
.text:00000001C009E343                 mov     edx, edi
.text:00000001C009E345                 shr     edx, 3          ; edx = 0x1e
.text:00000001C009E348                 add     edx, 7          ; edx = 0x25
.text:00000001C009E34B                 and     edx, 0FFFFFFF8h ; edx = 0x20
.text:00000001C009E34E                 add     edx, 10h        ; NumberOfBytes = 0x30
.text:00000001C009E351                 call    cs:__imp_ExAllocatePoolWithTag ; allocs 0x30 bytes for a RTL_BITMAP
.text:00000001C009E357                 mov     rbx, rax
.text:00000001C009E35A                 test    rax, rax
.text:00000001C009E35D                 jz      short loc_1C009E386
.text:00000001C009E35F                 lea     rdx, [rax+10h]  ; BitMapBuffer (0x30 - 0x10 bytes)
.text:00000001C009E363                 mov     r8d, edi        ; SizeOfBitMap (number of bits) = 0xF0
.text:00000001C009E366                 mov     rcx, rax        ; BitMapHeader
.text:00000001C009E369                 call    cs:__imp_RtlInitializeBitMap
.text:00000001C009E36F                 mov     rcx, rbx        ; BitMapHeader
.text:00000001C009E372                 call    cs:__imp_RtlClearAllBits
</pre></div>
<p>Besides allocating this <tt class="docutils literal">RTL_BITMAP</tt> structure, <tt class="docutils literal"><span class="pre">CSectionBitmapAllocator::Initialize()</span></tt> also generates a 64-bit random number, which is used as a <tt class="docutils literal">XOR</tt> key to encode pointers to the <tt class="docutils literal">View</tt> and <tt class="docutils literal">RTL_BITMAP</tt> objects that were previously allocated:</p>
<div class="highlight"><pre><span></span>.text:00000001C002DE38 private: bool NSInstrumentation::CSectionBitmapAllocator&lt;163840, 640&gt;::Initialize(unsigned char *) proc near
[...]
.text:00000001C002DE48                 rdtsc                   ; source for RtlRandomEx
.text:00000001C002DE4A                 shl     rdx, 20h
.text:00000001C002DE4E                 lea     rcx, [rsp+28h+arg_0]
.text:00000001C002DE53                 or      rax, rdx
.text:00000001C002DE56                 mov     [rsp+28h+arg_0], eax
.text:00000001C002DE5A                 call    cs:__imp_RtlRandomEx ; get a 32-bit random number
.text:00000001C002DE60                 mov     eax, eax
.text:00000001C002DE62                 lea     rcx, [rsp+28h+arg_0]
.text:00000001C002DE67                 shl     rax, 20h        ; shift eax to the higher part of RAX
.text:00000001C002DE6B                 mov     [rbx+10h], rax  ; CSectionBitmapAllocator-&gt;xor_key = random
.text:00000001C002DE6F                 call    cs:__imp_RtlRandomEx ; get another 32-bit random number
.text:00000001C002DE75                 mov     eax, eax
.text:00000001C002DE77                 or      [rbx+10h], rax  ; CSectionBitmapAllocator-&gt;xor_key |= another_random
</pre></div>
<p>The XORed pointers to the <tt class="docutils literal">View</tt> and <tt class="docutils literal">RTL_BITMAP</tt> objects are stored in the <tt class="docutils literal">CSectionBitmapAllocator</tt> structure.</p>
<div class="highlight"><pre><span></span>.text:00000001C002DEB8                 mov     rdx, [rbx+10h]  ; rdx = CSectionBitmapAllocator-&gt;xor_key
.text:00000001C002DEBC                 mov     rcx, rdx
.text:00000001C002DEBF                 xor     rcx, rax        ; rcx = CSectionBitmapAllocator-&gt;xor_key ^ RTL_BITMAP
.text:00000001C002DEC2                 mov     al, 1
.text:00000001C002DEC4                 xor     rdx, rdi        ; rdx = CSectionBitmapAllocator-&gt;xor_key ^ CSectionEntry-&gt;view
.text:00000001C002DEC7                 mov     [rbx+18h], rcx  ; CSectionBitmapAllocator-&gt;xored_rtl_bitmap = CSectionBitmapAllocator-&gt;xor_key ^ RTL_BITMAP
.text:00000001C002DECB                 mov     [rbx+8], rdx    ; CSectionBitmapAllocator-&gt;xored_view = CSectionBitmapAllocator-&gt;xor_key ^ CSectionEntry-&gt;view
</pre></div>
</div>
<div class="section" id="allocation">
<h3>Allocation</h3>
<p>The <tt class="docutils literal">win32kfull!NtGdiCreateBitmap()</tt> system call is in charge of creating GDI Bitmap objects. <tt class="docutils literal">win32kfull!NtGdiCreateBitmap()</tt> calls <tt class="docutils literal">win32kbase!GreCreateBitmap()</tt>, which in turn calls <tt class="docutils literal"><span class="pre">win32kbase!SURFMEM::bCreateDIB()</span></tt>.
The job of <tt class="docutils literal"><span class="pre">win32kbase!SURFMEM::bCreateDIB()</span></tt> is to allocate memory for the <tt class="docutils literal">SURFACE</tt> object. In previous versions of Windows, the pixel data buffer of a Bitmap was typically contiguous to the <tt class="docutils literal">SURFACE</tt> header; it didn't have to be necessarily like that, but it was done that way. This made possible to "extend" a pixel data buffer by corrupting the <tt class="docutils literal">sizlBitmap</tt> member of the <tt class="docutils literal">SURFACE</tt> header, as explained before, and making it overlap with the <tt class="docutils literal">SURFACE</tt> header of an adjacent Bitmap.</p>
<p>Starting from Windows 10 Fall Creators Update, <tt class="docutils literal"><span class="pre">win32kbase!SURFMEM::bCreateDIB</span></tt> ensures that the <tt class="docutils literal">SURFACE</tt> header and the pixel data buffer are allocated separately, using the <em>Type Isolation</em> mitigation.</p>
<p>The pixel data buffer is allocated on the <tt class="docutils literal">PagedPoolSession</tt> pool in a straightforward way, by calling a wrapper of <tt class="docutils literal">nt!ExAllocatePoolWithTag</tt>:</p>
<div class="highlight"><pre><span></span>SURFMEM::bCreateDIB+10B                  sub     r15d, r12d      ; alloc_size = requested_size - sizeof(SURFACE)
SURFMEM::bCreateDIB+10E                  jz      short loc_1C0038F91
SURFMEM::bCreateDIB+110                  call    cs:__imp_IsWin32AllocPoolImplSupported
SURFMEM::bCreateDIB+116                  test    eax, eax
SURFMEM::bCreateDIB+118                  js      loc_1C00C54D6
SURFMEM::bCreateDIB+11E                  mov     r8d, 'mbpG'                 ; Tag = 'Gpbm'
SURFMEM::bCreateDIB+124                  mov     edx, r15d                   ; NumberOfBytes = requested_size - sizeof(SURFACE)
SURFMEM::bCreateDIB+127                  mov     ecx, 21h                    ; PoolType = PagedPoolSession
SURFMEM::bCreateDIB+12C                  call    cs:__imp_Win32AllocPoolImpl ; &lt;&lt;&lt; allocation! only for the pixel_data_buffer
</pre></div>
<p>On the other hand, the <tt class="docutils literal">SURFACE</tt> header is now allocated from the <tt class="docutils literal">CTypeIsolation</tt> structures described earlier, by calling <tt class="docutils literal"><span class="pre">CTypeIsolation::AllocateType()</span></tt>. To be precise, this allocation returns a buffer located on a <tt class="docutils literal">View</tt> of a <tt class="docutils literal">Section</tt> object:</p>
<div class="highlight"><pre><span></span>SURFMEM::bCreateDIB+16C                  mov     rax, cs:uchar * * gpTypeIsolation
SURFMEM::bCreateDIB+173                  mov     rcx, [rax]
SURFMEM::bCreateDIB+176                  test    rcx, rcx
SURFMEM::bCreateDIB+179                  jz      loc_1C00C579D
SURFMEM::bCreateDIB+17F                  call    NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::AllocateType(void)
SURFMEM::bCreateDIB+184                  mov     rsi, rax        ; rsi = buffer for the SURFACE header
SURFMEM::bCreateDIB+187                  test    rax, rax        ; the returned buffer is a View of a Section object
SURFMEM::bCreateDIB+18A                  jz      loc_1C00C5791
</pre></div>
<p>By digging into the <tt class="docutils literal"><span class="pre">CTypeIsolation::AllocateType()</span></tt> function, we can see how the allocation algorithm works.</p>
<p><tt class="docutils literal"><span class="pre">CTypeIsolation::AllocateType()</span></tt> traverses the list of <tt class="docutils literal">CSectionEntry</tt> objects; for each <tt class="docutils literal">CSectionEntry</tt>, it checks if its <tt class="docutils literal">CSectionBitmapAllocator</tt> contains a clear bit in its backing <tt class="docutils literal">RTL_BITMAP</tt> structure, by calling <tt class="docutils literal">nt!RtlFindClearBits</tt>. It makes use of the <tt class="docutils literal">bitmap_hint_index</tt> member of the <tt class="docutils literal">CSectionBitmapAllocator</tt> to try and speed up the lookup.</p>
<div class="highlight"><pre><span></span>.text:00000001C0039863                 mov     r8d, ebp        ; HintIndex = 0
.text:00000001C0039866                 cmp     eax, 0F0h       ; bitmap_hint_index &gt;= RTL_BITMAP-&gt;size?
.text:00000001C003986B                 jnb     short loc_1C0039870
.text:00000001C003986D                 mov     r8d, eax        ; HintIndex = bitmap_hint_index
.text:00000001C0039870
.text:00000001C0039870 loc_1C0039870:                          ; CODE XREF: NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::AllocateType(void)+6Bj
.text:00000001C0039870                 mov     rcx, [rsi+18h]  ; rcx = CSectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C0039874                 mov     edx, 1          ; NumberToFind
.text:00000001C0039879                 xor     rcx, [rsi+10h]  ; BitMapHeader = CSectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C0039879                                         ; ^ CSectionBitmapAllocator-&gt;xor_key
.text:00000001C003987D                 call    cs:__imp_RtlFindClearBits
.text:00000001C0039883                 mov     r12d, eax       ; r12 = free_bit_index
.text:00000001C0039886                 cmp     eax, 0FFFFFFFFh ; free_bit_index == -1?
.text:00000001C0039889                 jz      short loc_1C00398D6 ; if so, RTL_BITMAP is full, check another CSectionEntry
</pre></div>
<p>If <tt class="docutils literal">nt!RtlFindClearBits</tt> returns -1, indicating that all the bits in the <tt class="docutils literal">RTL_BITMAP</tt> are set to 1 (that is, the <tt class="docutils literal">RTL_BITMAP</tt> is full), then it tries to repeat the operation with the next <tt class="docutils literal">CSectionEntry</tt> on the list. We'll explore this case later. Otherwise, if <tt class="docutils literal">nt!RtlFindClearBits</tt> returns a value different than -1, that means that the <tt class="docutils literal">RTL_BITMAP</tt> had at least 1 clear bit, and therefore that the Section memory on the current <tt class="docutils literal">CSectionEntry</tt> has at least 1 free slot for a <tt class="docutils literal">SURFACE</tt> header.</p>
<p>So we need to map the index of the clear bit in the <tt class="docutils literal">RTL_BITMAP</tt> -as returned by <tt class="docutils literal">nt!RtlFindClearBits()</tt>- into the corresponding memory address of a free slot in a <tt class="docutils literal">Section View</tt>.
For this purpose, the index of the clear bit is divided by 6, since each 0x1000-byte <tt class="docutils literal">View</tt> of the <tt class="docutils literal">Section</tt> is capable of holding 6 <tt class="docutils literal">SURFACE</tt> headers of size 0x280. The result is an index, which I call <tt class="docutils literal">view_index</tt> in the disassembly snippets below. This <tt class="docutils literal">view_index</tt> will be in the range [0, 0x27], since each <tt class="docutils literal">Section</tt> is 0x28000 bytes in size, and so it can be divided into 0x28 <tt class="docutils literal">Views</tt> of size 0x1000, and it's used to address one of the 0x28 possible <tt class="docutils literal">Views</tt> of a <tt class="docutils literal">Section</tt>.</p>
<p>This <tt class="docutils literal">view_index</tt> is compared against the count of actually committed Views for the current Section, as held in the <tt class="docutils literal">num_commited_views</tt> member of the <tt class="docutils literal">CSectionBitmapAllocator</tt> object. As explained in MSDN <a class="footnote-reference" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id11" id="id4">[4]</a>, <em>"no physical memory is allocated for a view until the virtual memory range is accessed"</em>.
If <tt class="docutils literal">view_index</tt> is smaller than the count of committed Views, then we don't need to commit a new View and we can go straight to the allocation. Otherwise, the address of the corresponding View is calculated (<tt class="docutils literal">first_view + view_index * 0x1000</tt>) and committed to physical memory by calling <tt class="docutils literal">nt!MmCommitSessionMappedView</tt>.</p>
<div class="highlight"><pre><span></span>.text:00000001C003988B                 mov     eax, 0AAAAAAABh
.text:00000001C0039890                 mul     r12d
.text:00000001C0039893                 mov     eax, [rsi+24h]  ; eax = CSectionBitmapAllocator-&gt;num_commited_views
.text:00000001C0039896                 mov     r15d, edx       ; HI_DWORD(free_bit_index * 0xaaaaaaab) / 4 == free_bit_index / 6
.text:00000001C0039899                 shr     r15d, 2         ; r15d = view_index = free_bit_index / 6 (6 SURFACE headers fit in 0x1000 bytes)
.text:00000001C003989D                 cmp     r15d, eax       ; view_index &lt; num_commited_views ?
.text:00000001C00398A0                 jb      loc_1C003998A   ; if so, no need to commit a new 0x1000-byte chunk from the View
.text:00000001C00398A6                 cmp     eax, 28h        ; num_commited_views &gt;= MAX_VIEW_INDEX ?
.text:00000001C00398A9                 jnb     loc_1C003998A
.text:00000001C00398AF                 mov     rbp, [rsi+8]
.text:00000001C00398AF                                         ; rbp = CSectionBitmapAllocator-&gt;xored_view
.text:00000001C00398B3                 mov     edx, r15d       ; edx = view_index
.text:00000001C00398B6                 xor     rbp, [rsi+10h]  ; CSectionBitmapAllocator-&gt;xored_view ^ CSectionBitmapAllocator-&gt;xor_key
.text:00000001C00398BA                 shl     edx, 0Ch        ; view_index * 0x1000
.text:00000001C00398BD                 add     rbp, rdx        ; rbp = view + view_index * 0x1000
.text:00000001C00398C0                 mov     edx, 1000h      ; edx = size to commit
.text:00000001C00398C5                 mov     rcx, rbp        ; rcx = addr of view to commit
.text:00000001C00398C8                 call    cs:__imp_MmCommitSessionMappedView
</pre></div>
<p>After a successful commit, the 0x1000-byte View is initialized to 0 (this write operation ends up doing the actual commit), and the <tt class="docutils literal">num_commited_views</tt> member of the <tt class="docutils literal">CSectionBitmapAllocator</tt> is updated accordingly.</p>
<div class="highlight"><pre><span></span>.text:00000001C0039975 loc_1C0039975:                          ; CODE XREF: NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::AllocateType(void)+D0j
.text:00000001C0039975                 xor     edx, edx        ; Val
.text:00000001C0039977                 mov     r8d, 1000h      ; Size
.text:00000001C003997D                 mov     rcx, rbp        ; Dst
.text:00000001C0039980                 call    memset          ; this memset actually commits the memory
.text:00000001C0039985                 inc     dword ptr [rsi+24h] ; CSectionBitmapAllocator-&gt;num_commited_views++
.text:00000001C0039988                 xor     ebp, ebp
</pre></div>
<p>Either if a new <tt class="docutils literal">View</tt> had to be committed or not, the index of the clear bit of the <tt class="docutils literal">RTL_BITMAP</tt> is then set to 1 by calling <tt class="docutils literal">nt!RtlSetBit()</tt>, in order to mark that bit as busy. Curiously enough, the code calls <tt class="docutils literal">nt!RtlTestBit()</tt> before setting the bit to 1, but the return value is not checked at all. Also, the <tt class="docutils literal">bitmap_hint_index</tt> member of the <tt class="docutils literal">CSectionBitmapAllocator</tt> is incremented by 1, resetting it to 0 if it happens to exceed the maximum value of 0xF0 - 1.</p>
<div class="highlight"><pre><span></span>.text:00000001C003998A                 mov     rcx, [rsi+18h]  ; rcx = CsectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C003998E                 mov     edx, r12d       ; BitNumber = free bit index
.text:00000001C0039991                 xor     rcx, [rsi+10h]  ; BitMapHeader = CSectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C0039991                                         ; ^ CSectionBitmapAllocator-&gt;xor_key
.text:00000001C0039995                 call    cs:__imp_RtlTestBit ; [!] return value not checked
.text:00000001C003999B                 mov     rcx, [rsi+18h]  ; rcx = CsectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C003999F                 mov     edx, r12d       ; BitNumber
.text:00000001C00399A2                 xor     rcx, [rsi+10h]  ; BitMapHeader = xored_rtl_bitmap ^ xor_key
.text:00000001C00399A6                 call    cs:__imp_RtlSetBit
.text:00000001C00399AC                 inc     dword ptr [rsi+20h] ; CSectionBitmapAllocator-&gt;bitmap_hint_index++
.text:00000001C00399AF                 cmp     dword ptr [rsi+20h], 0F0h ; CSectionBitmapAllocator-&gt;bitmap_hint_index &gt;= bitmap size?
.text:00000001C00399B6                 jnb     short loc_1C0039A27
[...]
.text:00000001C0039A27 loc_1C0039A27:                          ; CODE XREF: NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::AllocateType(void)+1B6j
.text:00000001C0039A27                 mov     [rsi+20h], ebp  ; CSectionBitmapAllocator-&gt;bitmap_hint_index = 0
.text:00000001C0039A2A                 jmp     short loc_1C00399B8
</pre></div>
<p>Now that we have mapped our clear bit into its corresponding <tt class="docutils literal">View</tt>, we need to select a 0x280-byte chunk within that <tt class="docutils literal">View</tt>. Each <tt class="docutils literal">View</tt> can hold 6 <tt class="docutils literal">SURFACE</tt> headers (0x1000 / 0x280 == 6).
In order to do that, the following calculation is done: <tt class="docutils literal">free_bit_index - view_index * 6</tt>, which simply equals <tt class="docutils literal">free_bit_index % 6</tt>.</p>
<div class="highlight"><pre><span></span>.text:00000001C00399B8                 mov     rax, [rsi+10h]  ; rax = CSectionBitmapAllocator-&gt;xor_key
.text:00000001C00399BC                 mov     ecx, r15d       ; ecx = view_index
.text:00000001C00399BF                 mov     rsi, [rsi+8]    ; rsi = CSectionBitmapAllocator-&gt;xored_view
.text:00000001C00399C3                 xor     edx, edx
.text:00000001C00399C5                 shl     ecx, 0Ch        ; ecx = view_index * 0x1000
.text:00000001C00399C8                 xor     rsi, rax        ; rsi = xored_view ^ xor_key
.text:00000001C00399CB                 add     rsi, rcx        ; rsi = view + view_index * 0x1000
.text:00000001C00399CE                 mov     rcx, rbx        ; rcx = CSectionBitmapAllocator-&gt;pushlock
.text:00000001C00399D1                 call    cs:__imp_ExReleasePushLockExclusiveEx
.text:00000001C00399D7                 call    cs:__imp_KeLeaveCriticalRegion
.text:00000001C00399DD                 lea     eax, [r15+r15*2] ; r15 == view_index
.text:00000001C00399E1                 add     eax, eax
.text:00000001C00399E3                 sub     r12d, eax       ; r12d = free_bit_index - view_index * 6 == free_bit_index % 6
.text:00000001C00399E6                 lea     ebx, [r12+r12*4]
.text:00000001C00399EA                 shl     ebx, 7          ; ebx = r12 * 0x5 * 0x80 == r12 * 0x280
.text:00000001C00399ED                 add     rbx, rsi        ; rbx += view + view_index * 0x1000
</pre></div>
<p>The value that <tt class="docutils literal">RBX</tt> gets at <tt class="docutils literal">0x1C00399ED</tt> is the address of the newly allocated <tt class="docutils literal">SURFACE</tt> header, and this is the value that will be returned by <tt class="docutils literal"><span class="pre">CTypeIsolation::AllocateType()</span></tt>.</p>
<p>For the sake of completeness, and as promised, here's what happens when <tt class="docutils literal">nt!RtlFindClearBits()</tt> returns -1, meaning that the <tt class="docutils literal">RTL_BITMAP</tt> of the current <tt class="docutils literal">CSectionEntry</tt> is full. In that case, the following conditional jump is taken:</p>
<div class="highlight"><pre><span></span>.text:00000001C0039870                 mov     rcx, [rsi+18h]  ; rcx = CSectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C0039874                 mov     edx, 1          ; NumberToFind
.text:00000001C0039879                 xor     rcx, [rsi+10h]  ; BitMapHeader = xored_rtl_bitmap ^ xor_key
.text:00000001C003987D                 call    cs:__imp_RtlFindClearBits
.text:00000001C0039883                 mov     r12d, eax       ; r12 = free_bit_index
.text:00000001C0039886                 cmp     eax, 0FFFFFFFFh ; free_bit_index == -1?
.text:00000001C0039889                 jz      short loc_1C00398D6 ; if so, RTL_BITMAP is full, check another CSectionEntry
</pre></div>
<p>That jump takes us here, where it checks if <tt class="docutils literal"><span class="pre">CSectionEntry-&gt;next</span> == CTypeIsolation</tt>, meaning that we've reached the end of the list of <tt class="docutils literal">CSectionEntry</tt> objects. If that's not the case, it loops and repeats the process with the next <tt class="docutils literal">CSectionEntry</tt> object.</p>
<div class="highlight"><pre><span></span>.text:00000001C00398D6 loc_1C00398D6:                          ; CODE XREF: NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::AllocateType(void)+89j
.text:00000001C00398D6                 lea     rcx, [rsp+48h+arg_0]
.text:00000001C00398DB                 call    NSInstrumentation::CAutoExclusiveCReaderWriterLock&lt;NSInstrumentation::CPlatformReaderWriterLock&gt;::~CAutoExclusiveCReaderWriterLock&lt;NSInstrumentation::CPlatformReaderWriterLock&gt;(void)
.text:00000001C00398E0 loc_1C00398E0:                          ; CODE XREF: NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::AllocateType(void)+1F0j
.text:00000001C00398E0                 mov     r14, [r14]      ; r14 = CSectionEntry-&gt;next
.text:00000001C00398E3                 mov     ebp, 0
.text:00000001C00398E8                 cmp     r14, r13        ; CSectionEntry-&gt;next == CTypeIsolation ?
.text:00000001C00398EB                 jnz     loc_1C0039843   ; if not, keep traversing the list
</pre></div>
<p>Otherwise, if we've reached the end of the list of <tt class="docutils literal">CSectionEntry</tt> objects without finding an empty slot (that is, every <tt class="docutils literal">CSectionEntry</tt> is holding its maximum of 0xF0 <tt class="docutils literal">SURFACE</tt> headers), the following code is reached. As shown below, it creates a new <tt class="docutils literal">CSectionEntry</tt>, and it calls <tt class="docutils literal"><span class="pre">CSectionBitmapAllocator::Allocate()</span></tt> on the <tt class="docutils literal">CSectionBitmapAllocator</tt> member of this new <tt class="docutils literal">CSectionEntry</tt>. As expected, <tt class="docutils literal"><span class="pre">CSectionBitmapAllocator::Allocate()</span></tt> mostly duplicates the procedure explained before: it finds a clear bit in the <tt class="docutils literal">RTL_BITMAP</tt>, it commits the 0x1000-bytes <tt class="docutils literal">View</tt> corresponding to said free bit, it marks that bit as busy in the <tt class="docutils literal">RTL_BITMAP</tt>, and finally it returns the address of the newly created <tt class="docutils literal">SURFACE</tt> header within the committed <tt class="docutils literal">View</tt>.</p>
<div class="highlight"><pre><span></span>.text:00000001C00398F1 loc_1C00398F1:                          ; CODE XREF: NSInstrumentation::CTypeIsolation&lt;163840,640&gt;::AllocateType(void)+3Dj
.text:00000001C00398F1                 xor     edx, edx        ; if we land here, that means that we finished traversing
.text:00000001C00398F1                                         ; the list of CSectionEntry, without finding an empty slot
.text:00000001C00398F3                 mov     rcx, rdi
.text:00000001C00398F6                 call    cs:__imp_ExReleasePushLockSharedEx
.text:00000001C00398FC                 call    cs:__imp_KeLeaveCriticalRegion
.text:00000001C0039902                 call    NSInstrumentation::CSectionEntry&lt;163840,640&gt;::Create(void)
.text:00000001C0039907                 mov     rdi, rax        ; rdi = new CSectionEntry
.text:00000001C003990A                 test    rax, rax
.text:00000001C003990D                 jz      short loc_1C003996D
.text:00000001C003990F                 mov     rcx, [rax+20h]  ; rcx = CSectionEntry-&gt;bitmap_allocator
.text:00000001C0039913                 call    NSInstrumentation::CSectionBitmapAllocator&lt;163840,640&gt;::Allocate(void) ; *** do the actual SURFACE header allocation
.text:00000001C0039918                 mov     rbp, rax        ; rbp = return value, allocated SURFACE header
</pre></div>
<p>Finally, the newly created <tt class="docutils literal">CSectionEntry</tt> is inserted at the end of the doubly linked list, as detailed below.
Notice that there is an integrity check before operating with the pointers of the list: the code verifies if the <tt class="docutils literal">next</tt> pointer of <tt class="docutils literal"><span class="pre">CTypeIsolation-&gt;previous</span></tt> points to the <tt class="docutils literal">CTypeIsolation</tt> head.</p>
<div class="highlight"><pre><span></span>.text:00000001C0039939                 mov     rcx, [r13+8]    ; rcx = CTypeIsolation-&gt;previous
.text:00000001C003993D                 cmp     [rcx], r13      ; CTypeIsolation-&gt;previous-&gt;next == CTypeIsolation ?
.text:00000001C0039940                 jnz     FatalListEntryError_9 ; if not, the list is corrupted
.text:00000001C0039946                 mov     [rdi+8], rcx    ; CSectionEntry-&gt;previous = CTypeIsolation-&gt;previous
.text:00000001C003994A                 xor     edx, edx
.text:00000001C003994C                 mov     [rdi], r13      ; CSectionEntry-&gt;next = CTypeIsolation
.text:00000001C003994F                 mov     [rcx], rdi      ; CTypeIsolation-&gt;previous-&gt;next = CSectionEntry
.text:00000001C0039952                 mov     rcx, rbx
.text:00000001C0039955                 add     dword ptr [r13+18h], 0F0h ; CTypeIsolation-&gt;size += 0xF0
.text:00000001C003995D                 mov     [r13+8], rdi    ; CTypeIsolation-&gt;previous = CSectionEntry
</pre></div>
</div>
<div class="section" id="deallocation">
<h3>Deallocation</h3>
<p>Deallocation of <tt class="docutils literal">SURFACE</tt> objects is done in the <tt class="docutils literal"><span class="pre">win32kbase!SURFACE::Free()</span></tt> function. This function starts by freeing the pool allocation that holds the pixel data buffer:</p>
<div class="highlight"><pre><span></span>.text:00000001C002DC9A                 cmp     byte ptr [rbp+270h], 0 ; boolean is_kernel_mode_pixel_data_buffer
.text:00000001C002DCA1 loc_1C002DCA1:                          ; DATA XREF: .rdata:00000001C017D540o
.text:00000001C002DCA1                 mov     [rsp+48h+arg_8], rbx
.text:00000001C002DCA6                 jz      short loc_1C002DCCC    ; if byte[SURFACE+0x270] == 0, the pixel data buffer is not freed
.text:00000001C002DCA8                 mov     rbx, [rbp+48h]  ; rbx = SURFACE-&gt;pvScan0
.text:00000001C002DCAC                 test    rbx, rbx
.text:00000001C002DCAF                 jz      short loc_1C002DCCC
.text:00000001C002DCB1                 call    cs:__imp_IsWin32FreePoolImplSupported
.text:00000001C002DCB7                 test    eax, eax
.text:00000001C002DCB9                 js      short loc_1C002DCC4
.text:00000001C002DCBB                 mov     rcx, rbx
.text:00000001C002DCBE                 call    cs:__imp_Win32FreePoolImpl ; frees the pixel data buffer
</pre></div>
<p>After that, it takes the <tt class="docutils literal">CTypeIsolation</tt> head and starts traversing the doubly linked list of <tt class="docutils literal">CSectionEntry</tt> objects, trying to determine which <tt class="docutils literal">CSectionEntry</tt> contains the <tt class="docutils literal">SURFACE</tt> header that it's trying to free. In order to do this, it simply checks if <tt class="docutils literal"><span class="pre">CSectionEntry-&gt;view</span> &lt;= SURFACE &lt;= <span class="pre">CSectionEntry-&gt;view</span> + 0x28000</tt>. Notice that there may be an error in this check, as it should probably be <tt class="docutils literal"><span class="pre">CSectionEntry-&gt;view</span> &lt;= SURFACE &lt; <span class="pre">CSectionEntry-&gt;view</span> + 0x28000</tt> (<tt class="docutils literal">&lt;</tt> instead of <tt class="docutils literal">&lt;=</tt> in the second comparison).</p>
<div class="highlight"><pre><span></span>.text:00000001C002DCCC                 mov     rax, cs:uchar * * gpTypeIsolation
.text:00000001C002DCD3                 mov     rsi, [rax]      ; rsi = CTypeIsolation head
[...]
.text:00000001C002DD08                 mov     rbx, [rsi]      ; rbx = CTypeIsolation-&gt;next
.text:00000001C002DD0B                 cmp     rbx, rsi        ; next == CTypeIsolation ?
.text:00000001C002DD0E                 jz      loc_1C002DDFF   ; if so, there's no CSectionEntry
.text:00000001C002DD14                 mov     r12, 0CCCCCCCCCCCCCCCDh
.text:00000001C002DD1E                 xchg    ax, ax
.text:00000001C002DD20 loc_1C002DD20:                          ; CODE XREF: SURFACE::Free(SURFACE *)+C5j
.text:00000001C002DD20                 mov     r14, [rbx+20h]  ; r14 = CSectionEntry-&gt;bitmap_allocator
.text:00000001C002DD24                 mov     r8, [r14+10h]   ; r8 = bitmap_allocator-&gt;xor_key
.text:00000001C002DD28                 mov     rax, r8
.text:00000001C002DD2B                 xor     rax, [r14+8]    ; rax = xor_key ^ xored_view
.text:00000001C002DD2F                 cmp     rbp, rax        ; SURFACE &lt; view?
.text:00000001C002DD32                 jb      short loc_1C002DD3F ; ...if so, skip to the next CSectionEntry
.text:00000001C002DD34                 add     rax, 28000h     ; view += section_size
.text:00000001C002DD3A                 cmp     rbp, rax        ; SURFACE &lt;= end of last view?
.text:00000001C002DD3D                 jbe     short loc_1C002DD4C ; if so, we found the view containing the SURFACE header
</pre></div>
<p>When these conditions are satisfied, meaning that we've found the <tt class="docutils literal">CSectionEntry</tt> containing the <tt class="docutils literal">SURFACE</tt> header to be freed, the index of that <tt class="docutils literal">SURFACE</tt> within its container <tt class="docutils literal">View</tt> is calculated (called here <tt class="docutils literal">index_within_view</tt>), by taking the 3 lower nibbles of the address of the <tt class="docutils literal">SURFACE</tt>, and dividing it by 0x280:</p>
<div class="highlight"><pre><span></span>.text:00000001C002DD4C loc_1C002DD4C:                          ; CODE XREF: SURFACE::Free(SURFACE *)+BDj
.text:00000001C002DD4C                 mov     rcx, rbp        ; rcx = SURFACE header
.text:00000001C002DD4F                 mov     rax, r12
.text:00000001C002DD52                 and     ecx, 0FFFh
.text:00000001C002DD58                 mul     rcx
.text:00000001C002DD5B                 mov     r15, rdx
.text:00000001C002DD5E                 shr     r15, 9          ; r15 = (SURFACE &amp; 0xfff) / 0x280 == index_within_view
.text:00000001C002DD62                 lea     rax, [r15+r15*4]
.text:00000001C002DD66                 shl     rax, 7          ; rax = r15 * 0x5 * 0x80 == r15 * 0x280
.text:00000001C002DD6A                 sub     rcx, rax        ; if rcx == rax, it's ok
.text:00000001C002DD6D                 jnz     short loc_1C002DD3F
</pre></div>
<p>Then, the address of <tt class="docutils literal">SURFACE</tt> needs to be mapped into the bit index that represents it in the <tt class="docutils literal">RTL_BITMAP</tt>. In order to obtain the corresponding bit index, it obtains the <tt class="docutils literal">view_index</tt> (that is, in which 0x1000-byte <tt class="docutils literal">View</tt> this <tt class="docutils literal">SURFACE</tt> object is located), and then it simply performs this calculation: <tt class="docutils literal">view_index * 6 + index_within_view</tt>.</p>
<div class="highlight"><pre><span></span>.text:00000001C002DD72                 mov     eax, ebp        ; eax = lo_dword(SURFACE)
.text:00000001C002DD74                 xor     ecx, [r14+8]    ; ecx = lo_dword(xor_key) ^ lo_dword(xored_view)
.text:00000001C002DD78                 sub     eax, ecx        ; eax = lo_dword(SURFACE) - lo_dword(view)
.text:00000001C002DD7A                 mov     rcx, [r14+18h]  ; rcx = CSectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C002DD7E                 shr     eax, 0Ch        ; eax /= 0x1000 == view_index
.text:00000001C002DD81                 xor     rcx, r8         ; BitMapHeader = xored_rtl_bitmap ^ xor_key
.text:00000001C002DD84                 lea     eax, [rax+rax*2]
.text:00000001C002DD87                 lea     edx, [r15+rax*2] ; BitNumber = view_index * 6 + index_within_view
.text:00000001C002DD8B                 call    cs:__imp_RtlTestBit
.text:00000001C002DD91                 test    al, al
.text:00000001C002DD93                 jz      short loc_1C002DD3F ; bit is turned off?
</pre></div>
<p>The value of the calculated bit index is tested via <tt class="docutils literal">nt!RtlTestBit()</tt>; if it's set to 1, as expected, then the execution flow continues in the code snippet below. As shown here, it calls <tt class="docutils literal"><span class="pre">CSectionBitmapAllocator::ContainsAllocation()</span></tt> (however the boolean value returned by this function is not checked at all), and then it clears the proper bit in the <tt class="docutils literal">RTL_BITMAP</tt> by calling <tt class="docutils literal">nt!RtlClearBit()</tt>, marking the slot as free. Finally, it clears the memory of the freed <tt class="docutils literal">SURFACE</tt> header by calling <tt class="docutils literal">memset()</tt>, and the bit index of the free slot is saved as the <tt class="docutils literal">bitmap_hint_index</tt>, in order to speed up future operations.</p>
<div class="highlight"><pre><span></span>.text:00000001C002DDA9                 mov     rdx, rbp        ; rdx = SURFACE header
.text:00000001C002DDAC                 mov     rcx, r14        ; rcx = bitmap_allocator
.text:00000001C002DDAF                 call    NSInstrumentation::CSectionBitmapAllocator&lt;163840,640&gt;::ContainsAllocation(void const *)
.text:00000001C002DDB4                 mov     ecx, [r14+8]    ; ecx = CSectionBitmapAllocator-&gt;xored_view
.text:00000001C002DDB8                 mov     eax, ebp        ; [!] return value from ContainsAllocation() is not checked
.text:00000001C002DDBA                 xor     ecx, [r14+10h]  ; CSectionBitmapAllocator-&gt;xored_view ^ CSectionBitmapAllocator-&gt;xor_key
.text:00000001C002DDBE                 sub     eax, ecx        ; eax = lo_dword(SURFACE) - lo_dword(view)
.text:00000001C002DDC0                 mov     rcx, [r14+18h]  ; rcx = CSectionBitmapAllocator-&gt;xored_rtl_bitmap
.text:00000001C002DDC4                 xor     rcx, [r14+10h]  ; BitMapHeader = xored_rtl_bitmap ^ xor_key
.text:00000001C002DDC8                 shr     eax, 0Ch        ; eax /= 0x1000 == view_index
.text:00000001C002DDCB                 lea     eax, [rax+rax*2]
.text:00000001C002DDCE                 lea     esi, [r15+rax*2]
.text:00000001C002DDD2                 mov     edx, esi        ; BitNumber = view_index * 6 + index_within_view
.text:00000001C002DDD4                 call    cs:__imp_RtlClearBit ; mark the slot as available
.text:00000001C002DDDA                 xor     edx, edx        ; Val
.text:00000001C002DDDC                 mov     r8d, 280h       ; Size
.text:00000001C002DDE2                 mov     rcx, rbp        ; Dst
.text:00000001C002DDE5                 call    memset          ; null-out the freed SURFACE header in the view
.text:00000001C002DDEA                 xor     edx, edx
.text:00000001C002DDEC                 mov     [r14+20h], esi  ; bitmap_allocator-&gt;bitmap_hint_index = index of freed slot
</pre></div>
</div>
<div class="section" id="windbg-extension">
<h3>Windbg extension</h3>
<p>While reverse engineering Win32k Type Isolation I developed a little WinDbg extension to help me dump the state of the Type Isolation structures. It is available at <a class="reference external" href="https://github.com/fdfalcon/TypeIsolationDbg">https://github.com/fdfalcon/TypeIsolationDbg</a>.</p>
<p>The WinDbg extension provides the following commands:</p>
<ul class="simple">
<li><tt class="docutils literal">!gptypeisolation [address]</tt>          : prints the top-level <tt class="docutils literal">CTypeIsolation</tt> structure (default address: <tt class="docutils literal">win32kbase!gpTypeIsolation</tt>)</li>
<li><tt class="docutils literal">!typeisolation [address]</tt>            : prints a <tt class="docutils literal"><span class="pre">NSInstrumentation::CTypeIsolation</span></tt> structure</li>
<li><tt class="docutils literal">!sectionentry [address]</tt>             : prints a <tt class="docutils literal"><span class="pre">NSInstrumentation::CSectionEntry</span></tt> structure</li>
<li><tt class="docutils literal">!sectionbitmapallocator [address]</tt>   : prints a <tt class="docutils literal"><span class="pre">NSInstrumentation::CSectionBitmapAllocator</span></tt> structure</li>
<li><tt class="docutils literal">!rtlbitmap [address]</tt>                : prints a <tt class="docutils literal">RTL_BITMAP</tt> structure</li>
</ul>
<p>The output of the extension includes some clickable links to help you follow the Type Isolation data structures. It also decodes XORed pointers to save you a step.
The following snippet shows the output of <tt class="docutils literal">TypeIsolationDbg</tt> when dumping the global <tt class="docutils literal">CTypeIsolation</tt> object and following the data structures for a single <tt class="docutils literal">CSectionEntry</tt>, all the way down to the map of bits representing the busy/free state of the <tt class="docutils literal">CSectionEntry</tt>'s slots:</p>
<div class="highlight"><pre><span></span>kd&gt; !gptypeisolation
win32kbase!gpTypeIsolation is at address 0xffffe6cf95138a98.
Pointer [1] stored at win32kbase!gpTypeIsolation: 0xffffe6a4400006b0.
Pointer [2]: 0xffffe6a440000680.
NSInstrumentation::CTypeIsolation
      +0x000 next                                : 0xffffe6a440000620
      +0x008 previous                            : 0xffffe6a441d8ca20
      +0x010 pushlock                            : 0xffffe6a440000660
      +0x018 size                                : 0xF00 [number of section entries: 0x10]

kd&gt; !sectionentry ffffe6a440000620
NSInstrumentation::CSectionEntry
      +0x000 next                                : 0xffffe6a441ca2470
      +0x008 previous                            : 0xffffe6a440000680
      +0x010 section                             : 0xffff86855f09f260
      +0x018 view                                : 0xffffe6a4403a0000
      +0x020 bitmap_allocator                    : 0xffffe6a4400005e0

kd&gt; !sectionbitmapallocator ffffe6a4400005e0
NSInstrumentation::CSectionBitmapAllocator
      +0x000 pushlock                            : 0xffffe6a4400005c0
      +0x008 xored_view                          : 0xa410b31c3f332f4c [decoded: 0xffffe6a4403a0000]
      +0x010 xor_key                             : 0x5bef55b87f092f4c
      +0x018 xored_rtl_bitmap                    : 0xa410b31c3f092acc [decoded: 0xffffe6a440000580]
      +0x020 bitmap_hint_index                   : 0xC0
      +0x024 num_commited_views                  : 0x27

kd&gt; !rtlbitmap ffffe6a440000580
RTL_BITMAP
      +0x000 size                                : 0xF0
      +0x008 bitmap_buffer                       : 0xffffe6a440000590

kd&gt; dyb ffffe6a440000590 L20
                   76543210 76543210 76543210 76543210
                   -------- -------- -------- --------
ffffe6a4`40000590  00000101 00000000 00000110 10110000  05 00 06 b0
ffffe6a4`40000594  00011100 10000000 11011011 11110110  1c 80 db f6
ffffe6a4`40000598  01111101 11111111 11111111 11111111  7d ff ff ff
ffffe6a4`4000059c  11111111 11011111 11110111 01111111  ff df f7 7f
ffffe6a4`400005a0  11111111 11111111 11111111 01111111  ff ff ff 7f
ffffe6a4`400005a4  11111101 11111001 11111111 01101111  fd f9 ff 6f
ffffe6a4`400005a8  11111110 11111111 11111111 11111111  fe ff ff ff
ffffe6a4`400005ac  11111111 00000011 00000000 00000000  ff 03 00 00
</pre></div>
</div>
<div class="section" id="conclusion">
<h3>Conclusion</h3>
<p>The Type Isolation mitigation implemented in the Win32k component of Windows 10 1709 modifies the way GDI Bitmap objects are allocated in kernel space: the <tt class="docutils literal">SURFACE</tt> header gets allocated on a <tt class="docutils literal">Section View</tt>, while the pixel data buffer is allocated on the <tt class="docutils literal">PagedPoolSession</tt> pool. This definitely eliminates the commodity exploitation technique of using Bitmaps as targets for limited memory corruption vulnerabilities, since it's not possible anymore to make an aligned spray of adjacent Bitmaps where the end of a pixel data buffer is immediately followed by the header of the next <tt class="docutils literal">SURFACE</tt> object.</p>
<p>Meanwhile, exploit writers have already transitioned to other useful kernel objects, such as <em>Palettes</em> <a class="footnote-reference" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id12" id="id5">[5]</a> <a class="footnote-reference" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id13" id="id6">[6]</a> <a class="footnote-reference" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id14" id="id7">[7]</a>.</p>
<p>As a curiosity, the <tt class="docutils literal">CSectionBitmapAllocator</tt> object keeps both the pointer to the <tt class="docutils literal">Section Views</tt> and the pointer to the <tt class="docutils literal">RTL_BITMAP</tt> obfuscated via a <tt class="docutils literal">XOR</tt> operation, however the parent <tt class="docutils literal">CSectionEntry</tt> structure keeps the same pointer to the <tt class="docutils literal">Views</tt> in plain.</p>
</div>
</div>
<div class="section" id="thanks">
<h2>Thanks</h2>
<p>A big thanks goes to my colleagues at Quarkslab for proof-reading this blogpost and providing feedback about it.</p>
<div class="section" id="references">
<h3>References</h3>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id1">[1]</a></td><td><a class="reference external" href="https://msdn.microsoft.com/en-us/library/dd183377(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/dd183377(v=vs.85).aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id2">[2]</a></td><td><a class="reference external" href="https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf">https://www.coresecurity.com/system/files/publications/2016/10/Abusing-GDI-Reloaded-ekoparty-2016_0.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id3">[3]</a></td><td><a class="reference external" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/section-objects-and-views</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id4">[4]</a></td><td><a class="reference external" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-memory-sections">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-memory-sections</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id5">[5]</a></td><td><a class="reference external" href="https://sensepost.com/blog/2017/abusing-gdi-objects-for-ring0-primitives-revolution/">https://sensepost.com/blog/2017/abusing-gdi-objects-for-ring0-primitives-revolution/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id6">[6]</a></td><td><a class="reference external" href="https://labs.bluefrostsecurity.de/files/Abusing_GDI_for_ring0_exploit_primitives_Evolution_Slides.pdf">https://labs.bluefrostsecurity.de/files/Abusing_GDI_for_ring0_exploit_primitives_Evolution_Slides.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://blog.quarkslab.com/reverse-engineering-the-win32k-type-isolation-mitigation.html#id7">[7]</a></td><td><a class="reference external" href="http://theevilbit.blogspot.com/2017/10/abusing-gdi-objects-for-kernel.html">http://theevilbit.blogspot.com/2017/10/abusing-gdi-objects-for-kernel.html</a></td></tr>
</tbody>
</table>
</div>
</div>

</div><!-- /.entry-content -->
<div class="comments">
  <h2>Comments</h2>
  <div id="disqus_thread"><iframe id="dsq-app9604" name="dsq-app9604" allowtransparency="true" frameborder="0" scrolling="no" tabindex="0" title="Disqus" width="100%" src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/saved_resource.html" style="width: 1px !important; min-width: 100% !important; border: none !important; overflow: hidden !important; height: 402px !important;" horizontalscrolling="no" verticalscrolling="no"></iframe></div>
  <script type="text/javascript">
    var disqus_identifier = "reverse-engineering-the-win32k-type-isolation-mitigation.html";
    (function() {
     var dsq = document.createElement('script');
     dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'https://Quarkslab.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] ||
      document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
                </div>
                </article>
                </section>
        </div><!--/span-->

      </div><!--/row-->

      <hr>

      <footer>
      <address id="about">
        Powered by <a href="http://docs.getpelican.com/">Pelican <i class="icon-external-link"></i></a>, Theme is from <a href="http://twitter.github.com/bootstrap/">Bootstrap from Twitter <i class="icon-external-link"></i></a>
      </address><!-- /#about -->
      </footer>

    </div><!--/.fluid-container-->


<script type="text/javascript">
    var disqus_shortname = 'Quarkslab';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>

    <!-- Le javascript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/jquery-1.7.2.min.js.下载"></script>
    <script src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/bootstrap.min.js.下载"></script>
  
<div id="goog-gt-tt" class="skiptranslate" dir="ltr"><div style="padding: 8px;"><div><div class="logo"><img src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/translate_24dp.png" width="20" height="20" alt="Google 翻译"></div></div></div><div class="top" style="padding: 8px; float: left; width: 100%;"><h1 class="title gray">原文</h1></div><div class="middle" style="padding: 8px;"><div class="original-text"></div></div><div class="bottom" style="padding: 8px;"><div class="activity-links"><span class="activity-link">提供更好的翻译建议</span><span class="activity-link"></span></div><div class="started-activity-container"><hr style="color: #CCC; background-color: #CCC; height: 1px; border: none;"><div class="activity-root"></div></div></div><div class="status-message" style="display: none;"></div></div><iframe style="display: none;" src="./Reverse Engineering the Win32k Type Isolation Mitigation_files/saved_resource(1).html"></iframe><div class="goog-te-spinner-pos"><div class="goog-te-spinner-animation"><svg xmlns="http://www.w3.org/2000/svg" class="goog-te-spinner" width="96px" height="96px" viewBox="0 0 66 66"><circle class="goog-te-spinner-path" fill="none" stroke-width="6" stroke-linecap="round" cx="33" cy="33" r="30"></circle></svg></div></div></body><div></div></html>